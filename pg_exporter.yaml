###############################################################
# PostgreSQL/Pgbouncer Metric Queries
# Author:   Vonng (fengruohang@outlook.com)
# Desc  :   pg_exporter metrics config files
# Ver   :   PostgreSQL 10, 11, 12, pgbouncer 1.9+
# Mtime :   2019-12-09
###############################################################



###############################################################
# Cluster Level Metrics
#   These are cluster level metrics (visible from all database)
#   cluster queries will not execute for each database of the
#   same cluster
###############################################################

#-------------------------------------------------------------#
# pg
# generic metrics
#-------------------------------------------------------------#

#-------------------------------------------------------------#
# this branch is for primary instance
#-------------------------------------------------------------#
pg_primary_only:
  name: pg
  query: |
    SELECT extract(EPOCH FROM CURRENT_TIMESTAMP)                  AS timestamp,
           pg_current_wal_lsn() - '0/0'                           AS lsn,
           pg_current_wal_insert_lsn() - '0/0'                    AS insert_lsn,
           pg_current_wal_lsn() - '0/0'                           AS write_lsn,
           pg_current_wal_flush_lsn() - '0/0'                     AS flush_lsn,
           extract(EPOCH FROM now() - pg_postmaster_start_time()) AS uptime,
           extract(EPOCH FROM now() - pg_conf_load_time())        AS conf_reload_time,
           pg_is_in_backup()                                      AS is_in_backup,
           extract(EPOCH FROM now() - pg_backup_start_time())     AS backup_time;

  ttl: 10
  tags: [cluster, primary]
  min_version: 100000
  skip_errors: true
  metrics:
    - timestamp:
        usage: GAUGE
        description: database current timestamp
    - lsn:
        usage: COUNTER
        description: log sequence number, current write location (on primary)
    - insert_lsn:
        usage: COUNTER
        description: primary only, location of current wal inserting
    - write_lsn:
        usage: COUNTER
        description: primary only, location of current wal writing
    - flush_lsn:
        usage: COUNTER
        description: primary only, location of current wal syncing
    - uptime:
        usage: GAUGE
        description: seconds since postmaster start
    - conf_reload_time:
        usage: GAUGE
        description: seconds since last configuration reload
    - is_in_backup:
        usage: GAUGE
        description: 1 if backup is in progress
    - backup_time:
        usage: GAUGE
        description: seconds since current backup start. null if don't have one


#-------------------------------------------------------------#
# this branch is for primary instance
#-------------------------------------------------------------#
pg_standby_only:
  name: pg
  query: |
    SELECT extract(EPOCH FROM CURRENT_TIMESTAMP)                                    AS timestamp,
           pg_last_wal_replay_lsn() - '0/0'                                         AS lsn,
           pg_last_wal_receive_lsn() - '0/0'                                        AS receive_lsn,
           pg_last_wal_replay_lsn() - '0/0'                                         AS replay_lsn,
           extract(EPOCH FROM now() - pg_postmaster_start_time())                   AS uptime,
           extract(EPOCH FROM now() - pg_conf_load_time())                          AS conf_reload_time,
           extract(EPOCH FROM pg_last_xact_replay_timestamp())                      AS last_replay_time,
           CASE WHEN pg_last_wal_receive_lsn() = pg_last_wal_replay_lsn() THEN 0
               ELSE EXTRACT(EPOCH FROM now() - pg_last_xact_replay_timestamp()) END AS lag,
           pg_is_in_backup()                                                        AS is_in_backup,
           extract(EPOCH FROM now() - pg_backup_start_time())                       AS backup_time;

  ttl: 10
  tags: [cluster, standby]
  min_version: 100000
  metrics:
    - timestamp:
        usage: GAUGE
        description: database current timestamp
    - lsn:
        usage: COUNTER
        description: log sequence number, current replay location (on standby)
    - receive_lsn:
        usage: COUNTER
        description: location of wal synced to disk (standby only)
    - replay_lsn:
        usage: COUNTER
        description: location of wal applied (on standby)
    - uptime:
        usage: GAUGE
        description: seconds since postmaster start
    - conf_reload_time:
        usage: GAUGE
        description: seconds since last configuration reload
    - last_replay_time:
        usage: GAUGE
        description: time when last transaction been replayed
    - lag:
        usage: GAUGE
        description: replication lag in seconds from view of standby server
    - is_in_backup:
        usage: GAUGE
        description: 1 if backup is in progress
    - backup_time:
        usage: GAUGE
        description: seconds since current backup start. null if don't have one#-------------------------------------------------------------#
# pg_repl
# replication metrics
#-------------------------------------------------------------#



#-------------------------------------------------------------#
# This branch is for PostgreSQL 10 ~ 12
# https://www.postgresql.org/docs/12/monitoring-stats.html#PG-STAT-REPLICATION-VIEW
#-------------------------------------------------------------#
pg_repl_10:
  name: pg_repl
  query: |
    SELECT pid,
      client_addr,
      application_name,
      state,
      CASE WHEN pg_is_in_recovery()
      THEN pg_last_wal_replay_lsn()
      ELSE pg_current_wal_lsn() END - '0/0' AS lsn,
      sent_lsn - '0/0'                          AS sent_lsn,
      write_lsn - '0/0'                         AS write_lsn,
      flush_lsn - '0/0'                         AS flush_lsn,
      replay_lsn - '0/0'                        AS replay_lsn,
      extract(EPOCH FROM write_lag)             AS write_lag,
      extract(EPOCH FROM flush_lag)             AS flush_lag,
      extract(EPOCH FROM replay_lag)            AS replay_lag,
      extract(EPOCH FROM now() - backend_start) AS backend_uptime,
      backend_xmin::TEXT::BIGINT                AS backend_xmin,
      sync_priority
      FROM pg_stat_replication;

  ttl: 10
  tags: [cluster]
  min_version: 100000
  metrics:
    - pid:
        usage: LABEL
        description: unique walsender pid
    - client_addr:
        usage: LABEL
        description: client address of wal receiver
    - application_name:
        usage: LABEL
        description: application name of standby
    - state:
        usage: LABEL
        description: replication state startup|catchup|streaming|backup|stopping
    - lsn:
        usage: COUNTER
        description: current log position on this server
    - sent_lsn:
        usage: COUNTER
        description: last log position sent to this standby server
    - write_lsn:
        usage: COUNTER
        description: last log position written to disk by this standby server
    - flush_lsn:
        usage: COUNTER
        description: last log position flushed to disk by this standby server
    - replay_lsn:
        usage: COUNTER
        description: last log position replayed into the database on this standby server
    - write_lag:
        usage: GAUGE
        description: latest ACK lsn diff with write (sync-remote-write lag)
    - flush_lag:
        usage: GAUGE
        description: latest ACK lsn diff with flush (sync-remote-flush lag)
    - replay_lag:
        usage: GAUGE
        description: latest ACK lsn diff with replay (sync-remote-apply lag)
    - backend_uptime:
        usage: GAUGE
        description: how long since standby connect to this server
    - backend_xmin:
        usage: GAUGE
        description: this standby's xmin horizon reported by hot_standby_feedback.
    - sync_priority:
        usage: GAUGE
        description: priority of being chosen as synchronous standby


#-------------------------------------------------------------#
# This branch is for PostgreSQL 94 ~ 96
# which does not have write_lag, replay_lag, flush_lag
# https://www.postgresql.org/docs/9.4/monitoring-stats.html#PG-STAT-REPLICATION-VIEW
#-------------------------------------------------------------#
pg_repl_94:
  name: pg_repl
  query: |
    SELECT pid,
      client_addr,
      application_name,
      state,
      CASE WHEN pg_is_in_recovery()
      THEN pg_last_wal_replay_lsn()
      ELSE pg_current_wal_lsn() END - '0/0' AS lsn,
      sent_lsn - '0/0'                          AS sent_lsn,
      write_lsn - '0/0'                         AS write_lsn,
      flush_lsn - '0/0'                         AS flush_lsn,
      replay_lsn - '0/0'                        AS replay_lsn,
      extract(EPOCH FROM now() - backend_start) AS backend_uptime,
      backend_xmin::TEXT::BIGINT                AS backend_xmin,
      sync_priority
      FROM pg_stat_replication;

  ttl: 10
  tags: [cluster]
  min_version: 090400
  max_version: 100000
  metrics:
    - pid:
        usage: LABEL
        description: unique walsender pid
    - client_addr:
        usage: LABEL
        description: client address of wal receiver
    - application_name:
        usage: LABEL
        description: application name of standby
    - state:
        usage: LABEL
        description: replication state startup|catchup|streaming|backup|stopping
    - lsn:
        usage: COUNTER
        description: current log position on this server
    - sent_lsn:
        usage: COUNTER
        description: last log position sent to this standby server
    - write_lsn:
        usage: COUNTER
        description: last log position written to disk by this standby server
    - flush_lsn:
        usage: COUNTER
        description: last log position flushed to disk by this standby server
    - replay_lsn:
        usage: COUNTER
        description: last log position replayed into the database on this standby server
    - backend_uptime:
        usage: GAUGE
        description: how long since standby connect to this server
    - backend_xmin:
        usage: GAUGE
        description: this standby's xmin horizon reported by hot_standby_feedback.
    - sync_priority:
        usage: GAUGE
        description: priority of being chosen as synchronous standby
#-------------------------------------------------------------#
# pg_slot
# replication slots
# https://www.postgresql.org/docs/12/view-pg-replication-slots.html
# 9.4 has 9 fields: slot_name, plugin, slot_type, datoid, database, active, xmin, catalog_xmin, restart_lsn
# 9.5 add 1: active_pid
# 9.6 add 1: confirmed_flush_lsn
# 10  add 1: temporary
# 10 - 12 : fixed 12 fields
#-------------------------------------------------------------#

#-------------------------------------------------------------#
# pg_slot branch 10+
#-------------------------------------------------------------#
pg_slot_10:
  name: pg_slot
  query: |
    SELECT slot_name,
      database                    AS datname,
      active,
      temporary,
      xmin::TEXT::BIGINT          AS xmin,
      catalog_xmin::TEXT::BIGINT  AS catalog_xmin,
      restart_lsn - '0/0'         AS restart_lsn,
      confirmed_flush_lsn - '0/0' AS confirm_lsn,
      CASE WHEN pg_is_in_recovery()
      THEN pg_last_wal_replay_lsn()
      ELSE pg_current_wal_lsn() END - restart_lsn
      AS retained_bytes
    FROM pg_replication_slots;

  ttl: 10
  tags: [cluster]
  min_version: 100000
  skip_errors: true
  metrics:
    - slot_name:
        usage: LABEL
        description: replication slot name
    - datname:
        usage: LABEL
        description: associated database name, only logical slot have this
    - active:
        usage: GAUGE
        description: whether the slot is currently being used
    - temporary:
        usage: GAUGE
        description: whether the slot is a temporary replication slot
    - xmin:
        usage: GAUGE
        description: oldest txid that this slot needs the database to retain
    - catalog_xmin:
        usage: GAUGE
        description: oldest txid that this slot needs the database to retain for catalog
    - restart_lsn:
        usage: COUNTER
        description: lsn that needs retain, wal after that will be kept
    - confirm_lsn:
        usage: COUNTER
        description: lsn that confirmed by logical standby, null for physical slot
    - retained_bytes:
        usage: GAUGE
        description: bytes retained for this slot

#-------------------------------------------------------------#
# pg_slot branch 9.6
# remove temporary
#-------------------------------------------------------------#
pg_slot_96:
  name: pg_slot
  query: |
    SELECT slot_name,
      database                    AS datname,
      active,
      xmin::TEXT::BIGINT          AS xmin,
      catalog_xmin::TEXT::BIGINT  AS catalog_xmin,
      restart_lsn - '0/0'         AS restart_lsn,
      confirmed_flush_lsn - '0/0' AS confirm_lsn,
      CASE WHEN pg_is_in_recovery()
      THEN pg_last_wal_replay_lsn()
      ELSE pg_current_wal_lsn() END - restart_lsn
      AS retained_bytes
    FROM pg_replication_slots;

  ttl: 10
  tags: [cluster]
  min_version: 090600
  max_version: 100000
  skip_errors: true
  metrics:
    - slot_name:
        usage: LABEL
        description: replication slot name
    - datname:
        usage: LABEL
        description: associated database name, only logical slot have this
    - active:
        usage: GAUGE
        description: whether the slot is currently being used
    - xmin:
        usage: GAUGE
        description: oldest txid that this slot needs the database to retain
    - catalog_xmin:
        usage: GAUGE
        description: oldest txid that this slot needs the database to retain for catalog
    - restart_lsn:
        usage: COUNTER
        description: lsn that needs retain, wal after that will be kept
    - confirm_lsn:
        usage: COUNTER
        description: lsn that confirmed by logical standby, null for physical slot
    - retained_bytes:
        usage: GAUGE
        description: bytes retained for this slot


#-------------------------------------------------------------#
# pg_slot branch 9.4
# remove active_pid, confirmed_flush_lsn
#-------------------------------------------------------------#
pg_slot_94:
  name: pg_slot
  query: |
    SELECT slot_name,
      database                    AS datname,
      active,
      xmin::TEXT::BIGINT          AS xmin,
      catalog_xmin::TEXT::BIGINT  AS catalog_xmin,
      restart_lsn - '0/0'         AS restart_lsn,
      CASE WHEN pg_is_in_recovery()
      THEN pg_last_wal_replay_lsn()
      ELSE pg_current_wal_lsn() END - restart_lsn
      AS retained_bytes
    FROM pg_replication_slots;

  ttl: 10
  tags: [cluster]
  min_version: 090400
  max_version: 090600
  skip_errors: true
  metrics:
    - slot_name:
        usage: LABEL
        description: replication slot name
    - datname:
        usage: LABEL
        description: associated database name, only logical slot have this
    - active:
        usage: GAUGE
        description: whether the slot is currently being used
    - xmin:
        usage: GAUGE
        description: oldest txid that this slot needs the database to retain
    - catalog_xmin:
        usage: GAUGE
        description: oldest txid that this slot needs the database to retain for catalog
    - restart_lsn:
        usage: COUNTER
        description: lsn that needs retain, wal after that will be kept
    - retained_bytes:
        usage: GAUGE
        description: bytes retained for this slot
#-------------------------------------------------------------#
# pg_bgwriter
# Postgresql background writer
# https://www.postgresql.org/docs/12/monitoring-stats.html#PG-STAT-BGWRITER-VIEW
#-------------------------------------------------------------#


#-------------------------------------------------------------#
# pg_bgwriter
# 9.4 ~ 12 is always the same
#-------------------------------------------------------------#
pg_bgwriter:
  query: |
    SELECT checkpoints_timed,
           checkpoints_req,
           checkpoint_write_time,
           checkpoint_sync_time,
           buffers_checkpoint,
           buffers_clean,
           buffers_backend,
           maxwritten_clean,
           buffers_backend_fsync,
           buffers_alloc,
           stats_reset
    FROM pg_stat_bgwriter;

  ttl: 10
  tags: [cluster]
  min_version: 090400
  metrics:
    - checkpoints_timed:
        usage: COUNTER
        description: scheduled checkpoints that have been performed
    - checkpoints_req:
        usage: COUNTER
        description: requested checkpoints that have been performed
    - checkpoint_write_time:
        usage: COUNTER
        description: time spending on writing files to disk, in µs
    - checkpoint_sync_time:
        usage: COUNTER
        description: time spending on syncing files to disk, in µs
    - buffers_checkpoint:
        usage: COUNTER
        description: buffers written during checkpoints
    - buffers_clean:
        usage: COUNTER
        description: buffers written by the background writer
    - buffers_backend:
        usage: COUNTER
        description: buffers written directly by a backend
    - maxwritten_clean:
        usage: COUNTER
        description: times that bgwriter stopped a cleaning scan
    - buffers_backend_fsync:
        usage: COUNTER
        description: times a backend had to execute its own fsync
    - buffers_alloc:
        usage: COUNTER
        description: buffers allocated
    - stats_reset:
        usage: COUNTER
        description: time when statistics were last reset

#-------------------------------------------------------------#
# pg_standby
# pg_stat_wal_receiver is introduced in 9.6
# add 2 new fields sender host/port in 11
# https://www.postgresql.org/docs/12/monitoring-stats.html#PG-STAT-WAL-RECEIVER-VIEW
#-------------------------------------------------------------#


#-------------------------------------------------------------#
# pg_standby version 11+
# v11 add sender_host & sender_port
#-------------------------------------------------------------#
pg_standby_11:
  name: pg_standby
  query: |
    SELECT pid,
           status,
           coalesce(sender_host, (regexp_match(conninfo, '.*host=(\S+).*'))[1])       AS host,
           coalesce(sender_port::TEXT, (regexp_match(conninfo, '.*port=(\S+).*'))[1]) AS port,
           slot_name,
           receive_start_lsn - '0/0'                                                  AS init_lsn,
           receive_start_tli                                                          AS init_tli,
           received_lsn - '0/0'                                                       AS last_lsn,
           received_tli                                                               AS last_tli,
           last_msg_send_time                                                         AS send_ts,
           last_msg_receipt_time                                                      AS receive_ts,
           latest_end_lsn - '0/0'                                                     AS report_lsn,
           latest_end_time                                                            AS report_ts,
           now()                                                                      AS current_ts
    FROM pg_stat_wal_receiver;

  ttl: 10
  tags: [cluster, standby]
  min_version: 110000
  skip_errors: true
  metrics:
    - pid:
        usage: LABEL
        description: pid of the WAL receiver process
    - status:
        usage: LABEL
        description: status of the WAL receiver process
    - host:
        usage: LABEL
        description:  location this WAL receiver is connected to
    - port:
        usage: LABEL
        description:  location port number this WAL receiver is connected to
    - slot_name:
        usage: LABEL
        description:  Replication slot name used by this WAL receiver
    - init_lsn:
        usage: COUNTER
        description: first time received lsn when WAL receiver is started
    - init_tli:
        usage: GAUGE
        description: first time received timeline number when WAL receiver is started
    - last_lsn:
        usage: COUNTER
        description: latest lsn that already flushed to standby disk
    - last_tli:
        usage: GAUGE
        description: latest timeline that already flushed to standby disk
    - send_ts:
        usage: GAUGE
        description: send time of last message received from origin WAL sender
    - receive_ts:
        usage: GAUGE
        description: receipt time of last message received from origin WAL sender
    - report_lsn:
        usage: COUNTER
        description: with time zone	Time of last write-ahead log location reported to origin WAL sender
    - report_ts:
        usage: GAUGE
        description: timestamp of last time reporting to sender
    - current_ts:
        usage: GAUGE
        description: current_timestamp


#-------------------------------------------------------------#
# pg_standby version 96
# extact sender_host & sender_port from conn_info
# https://www.postgresql.org/docs/9.6/monitoring-stats.html#PG-STAT-WAL-RECEIVER-VIEW
#-------------------------------------------------------------#
pg_standby_96:
  name: pg_standby
  query: |
    SELECT pid,
           status,
           (regexp_match(conninfo, '.*host=(\S+).*'))[1] AS host,
           (regexp_match(conninfo, '.*port=(\S+).*'))[1] AS port,
           slot_name,
           receive_start_lsn - '0/0'                     AS init_lsn,
           receive_start_tli                             AS init_tli,
           received_lsn - '0/0'                          AS last_lsn,
           received_tli                                  AS last_tli,
           last_msg_send_time                            AS send_ts,
           last_msg_receipt_time                         AS receive_ts,
           latest_end_lsn - '0/0'                        AS report_lsn,
           latest_end_time                               AS report_ts,
           now()                                         AS current_ts
    FROM pg_stat_wal_receiver;

  ttl: 10
  tags: [cluster, standby]
  min_version: 090600
  max_version: 110000
  skip_errors: true
  metrics:
    - pid:
        usage: LABEL
        description: pid of the WAL receiver process
    - status:
        usage: LABEL
        description: status of the WAL receiver process
    - host:
        usage: LABEL
        description:  location this WAL receiver is connected to
    - port:
        usage: LABEL
        description:  location port number this WAL receiver is connected to
    - slot_name:
        usage: LABEL
        description:  Replication slot name used by this WAL receiver
    - init_lsn:
        usage: COUNTER
        description: first time received lsn when WAL receiver is started
    - init_tli:
        usage: GAUGE
        description: first time received timeline number when WAL receiver is started
    - last_lsn:
        usage: COUNTER
        description: latest lsn that already flushed to standby disk
    - last_tli:
        usage: GAUGE
        description: latest timeline that already flushed to standby disk
    - send_ts:
        usage: GAUGE
        description: send time of last message received from origin WAL sender
    - receive_ts:
        usage: GAUGE
        description: receipt time of last message received from origin WAL sender
    - report_lsn:
        usage: COUNTER
        description: with time zone	Time of last write-ahead log location reported to origin WAL sender
    - report_ts:
        usage: GAUGE
        description: timestamp of last time reporting to sender
    - current_ts:
        usage: GAUGE
        description: current_timestamp
#-------------------------------------------------------------#
# pg_recovery
#-------------------------------------------------------------#

pg_recovery:
  query: |
    SELECT min_recovery_end_timeline    AS min_timeline,
           min_recovery_end_lsn - '0/0' AS min_lsn,
           backup_start_lsn - '0/0'     AS backup_start_lsn,
           backup_end_lsn - '0/0'       AS backup_end_lsn,
           end_of_backup_record_required AS require_record
    FROM pg_control_recovery();

  ttl: 100
  tags: [cluster]
  min_version: 090600
  skip_errors: true
  metrics:
    - min_timeline:
        usage: COUNTER
        description: pg control recovery min timeline
    - min_lsn:
        usage: COUNTER
        description: pg control recovery min lsn
    - backup_start_lsn:
        usage: COUNTER
        description: pg control recovery backup start lsn
    - backup_end_lsn:
        usage: COUNTER
        description: pg control recovery backup end lsn
    - require_record:
        usage: GAUGE
        description: do recovery need a end of backup record

#-------------------------------------------------------------#
# pg_checkpoint
# pg control checkpoint
# 96 introduced 19 fields
# 10  checkpoint_location/prior_location/redo_location location to lsn
# 11 remove prior_lsn fields
#-------------------------------------------------------------#


#-------------------------------------------------------------#
# pg_checkpoint branch 10
# since prior_lsn is not fetched, this is compatible with ver10
#-------------------------------------------------------------#
pg_checkpoint_10:
  name: pg_checkpoint
  query: |
    SELECT checkpoint_lsn - '0/0'                      AS checkpoint_lsn,
           redo_lsn - '0/0'                            AS redo_lsn,
           timeline_id                                 AS tli,
           prev_timeline_id                            AS prev_tli,
           full_page_writes,
           split_part(next_xid, ':', 1)                AS next_xid_epoch,
           split_part(next_xid, ':', 2)                AS next_xid,
           next_oid::BIGINT,
           next_multixact_id::text::BIGINT,
           next_multi_offset::text::BIGINT,
           oldest_xid::text::BIGINT,
           oldest_xid_dbid::text::BIGINT,
           oldest_active_xid::text::BIGINT,
           oldest_multi_xid::text::BIGINT,
           oldest_multi_dbid::BIGINT,
           oldest_commit_ts_xid::text::BIGINT,
           newest_commit_ts_xid::text::BIGINT,
           checkpoint_time                             AS time,
           extract(epoch from now() - checkpoint_time) AS elapse
    FROM pg_control_checkpoint();

  ttl: 100
  tags: [cluster]
  min_version: 100000
  skip_errors: true
  metrics:
    - checkpoint_lsn:
        usage: COUNTER
        description: lsn of checkpoint
    - redo_lsn:
        usage: COUNTER
        description: redo start LSN
    - tli:
        usage: GAUGE
        description: current WAL timeline
    - prev_tli:
        usage: GAUGE
        description: previous WAL timeline
    - full_page_writes:
        usage: GAUGE
        description: is full page write enabled ?
    - next_xid_epoch:
        usage: GAUGE
        description: next xid epoch since this checkpoint
    - next_xid:
        usage: GAUGE
        description: next xid since this checkpoint
    - next_oid:
        usage: GAUGE
        description: next object id since this checkpoint
    - next_multixact_id:
        usage: GAUGE
        description: next multixact id of this checkpoint
    - next_multi_offset:
        usage: GAUGE
        description: next multixact id offset of this checkpoint
    - oldest_xid:
        usage: GAUGE
        description: oldest existing xid of the checkpoint
    - oldest_xid_dbid:
        usage: GAUGE
        description: which db contains the oldest xid
    - oldest_active_xid:
        usage: GAUGE
        description: oldest active xid of the checkpoint
    - oldest_multi_xid:
        usage: GAUGE
        description: oldest active multi xid of the checkpoint
    - oldest_multi_dbid:
        usage: GAUGE
        description: which db contins the oldest multi xid
    - oldest_commit_ts_xid:
        usage: GAUGE
        description: xid with oldest commit ts by the checkpoint
    - newest_commit_ts_xid:
        usage: GAUGE
        description: xid with newest commit ts by the checkpoint
    - time:
        usage: GAUGE
        description: timestamp of this checkpoint
    - elapse:
        usage: GAUGE
        description: time elapsed since this checkpoint in seconds


#-------------------------------------------------------------#
# pg_checkpoint branch 96
# https://www.postgresql.org/docs/9.6/functions-info.html#FUNCTIONS-PG-CONTROL-CHECKPOINT
#-------------------------------------------------------------#

pg_checkpoint_96:
  name: pg_checkpoint
  query: |
    SELECT checkpoint_location - '0/0'                 AS checkpoint_lsn,
           prior_location - '0/0'                      AS prior_lsn,
           redo_location - '0/0'                       AS redo_lsn,
           timeline_id                                 AS tli,
           prev_timeline_id                            AS prev_tli,
           full_page_writes,
           split_part(next_xid, ':', 1)                AS next_xid_epoch,
           split_part(next_xid, ':', 2)                AS next_xid,
           next_oid::BIGINT,
           next_multixact_id::text::BIGINT,
           next_multi_offset::text::BIGINT,
           oldest_xid::text::BIGINT,
           oldest_xid_dbid::text::BIGINT,
           oldest_active_xid::text::BIGINT,
           oldest_multi_xid::text::BIGINT,
           oldest_multi_dbid::BIGINT,
           oldest_commit_ts_xid::text::BIGINT,
           newest_commit_ts_xid::text::BIGINT,
           checkpoint_time                             AS time,
           extract(epoch from now() - checkpoint_time) AS elapse
    FROM pg_control_checkpoint();

  ttl: 100
  tags: [cluster]
  min_version: 090600
  max_version: 100000
  skip_errors: true
  metrics:
    - checkpoint_lsn:
        usage: COUNTER
        description: lsn of checkpoint
    - prior_lsn:
        usage: COUNTER
        description: prior checkpoint lsn
    - redo_lsn:
        usage: COUNTER
        description: redo start LSN
    - tli:
        usage: GAUGE
        description: current WAL timeline
    - prev_tli:
        usage: GAUGE
        description: previous WAL timeline
    - full_page_writes:
        usage: GAUGE
        description: is full page write enabled ?
    - next_xid_epoch:
        usage: GAUGE
        description: next xid epoch since this checkpoint
    - next_xid:
        usage: GAUGE
        description: next xid since this checkpoint
    - next_oid:
        usage: GAUGE
        description: next object id since this checkpoint
    - next_multixact_id:
        usage: GAUGE
        description: next multixact id of this checkpoint
    - next_multi_offset:
        usage: GAUGE
        description: next multixact id offset of this checkpoint
    - oldest_xid:
        usage: GAUGE
        description: oldest existing xid of the checkpoint
    - oldest_xid_dbid:
        usage: GAUGE
        description: which db contains the oldest xid
    - oldest_active_xid:
        usage: GAUGE
        description: oldest active xid of the checkpoint
    - oldest_multi_xid:
        usage: GAUGE
        description: oldest active multi xid of the checkpoint
    - oldest_multi_dbid:
        usage: GAUGE
        description: which db contins the oldest multi xid
    - oldest_commit_ts_xid:
        usage: GAUGE
        description: xid with oldest commit ts by the checkpoint
    - newest_commit_ts_xid:
        usage: GAUGE
        description: xid with newest commit ts by the checkpoint
    - time:
        usage: GAUGE
        description: timestamp of this checkpoint
    - elapse:
        usage: GAUGE
        description: time elapsed since this checkpoint in seconds

#-------------------------------------------------------------#
# pg_activity
# backend session group by state
#-------------------------------------------------------------#

pg_activity:
  query: |
    SELECT datname,
           state,
           coalesce(count, 0)             AS count,
           coalesce(max_duration, 0)      AS max_duration,
           coalesce(max_tx_duration, 0)   AS max_tx_duration,
           coalesce(max_conn_duration, 0) AS max_conn_duration
    FROM (SELECT d.oid AS database, d.datname, a.state
          FROM pg_database d,
               unnest(ARRAY ['active','idle','idle in transaction','idle in transaction (aborted)','fastpath function call','disabled']) a(state)
          WHERE d.datname NOT IN ('postgres','template0','template1')) base
             LEFT JOIN (
        SELECT datname, state,
               count(*) AS count,
               max(extract(epoch from now() - state_change)) AS max_duration,
               max(extract(epoch from now() - xact_start))   AS max_tx_duration,
               max(extract(epoch from now() - backend_start)) AS max_conn_duration
        FROM pg_stat_activity WHERE backend_type = 'client backend' AND pid <> pg_backend_pid()
        GROUP BY datname, state
    ) a USING (datname, state);

  ttl: 10
  tags: [cluster]
  min_version: 090400
  skip_errors: true
  metrics:
    - datname:
        usage: LABEL
        description: database name
    - state:
        usage: LABEL
        description: client backend connection state
    - count:
        usage: GAUGE
        description: connection count of given (datname,state)
    - max_duration:
        usage: GAUGE
        description: max duration since state change among (datname, state)
    - max_tx_duration:
        usage: GAUGE
        description: max transaction duration since state change among (datname, state)
    - max_conn_duration:
        usage: GAUGE
        description: max backend session duration since state change among (datname, state)


#-------------------------------------------------------------#
# pg_wait
# note that in 9.6 wait_event is introduced
#-------------------------------------------------------------#

pg_wait:
  query: |
    SELECT datname, wait_event_type AS event, count(*) AS count
    FROM pg_stat_activity
    WHERE datname NOT IN ('postgres', 'template0', 'template1')
      AND backend_type = 'client backend'
      AND pid <> pg_backend_pid()
    GROUP BY datname, wait_event_type;

  ttl: 10
  tags: [cluster]
  min_version: 090600
  skip_errors: true
  metrics:
    - datname:
        usage: LABEL
        description: database name
    - event:
        usage: LABEL
        description: wait event type, LWLock, Lock, BufferPin, Activity, Extension, Client, IPC, Timeout, IO
    - count:
        usage: GAUGE
        description: wait event type count

#-------------------------------------------------------------#
# pg_xact
#-------------------------------------------------------------#
pg_xact:
  query: |
    WITH snap(v) AS (SELECT txid_current_snapshot()),
         xset(v) AS  (SELECT txid_snapshot_xip(v) FROM snap),
         xnum(v) AS (SELECT count(*) from xset),
         xmin(v) AS (SELECT txid_snapshot_xmin(v) FROM snap),
         xmax(v) AS (SELECT txid_snapshot_xmin(v) FROM snap)
    SELECT xmin.v AS xmin, xmax.v AS xmax, xnum.v AS xnum FROM xmin, xmax, xnum;

  ttl: 10
  tags: [cluster]
  min_version: 090400
  skip_errors: true

  metrics:
    - xmin:
        usage: GAUGE
        description: earliest txid that is still active
    - xmax:
        usage: GAUGE
        description: first as-yet-unassigned txid. txid >= this are invisible.
    - xnum:
        usage: GAUGE
        description: current active transaction count

#-------------------------------------------------------------#
# pg_lock
#-------------------------------------------------------------#

pg_lock:
  query: |
    SELECT datname, mode, coalesce(count, 0) AS count
    FROM (SELECT d.oid AS database, d.datname, l.mode FROM pg_database d,
               unnest(ARRAY ['AccessShareLock','RowShareLock','RowExclusiveLock','ShareUpdateExclusiveLock',
                   'ShareLock','ShareRowExclusiveLock','ExclusiveLock','AccessExclusiveLock']) l(mode)
          WHERE d.datname NOT IN ('postgres','template0','template1')) base
             LEFT JOIN (SELECT database, mode, count(*) AS count FROM pg_locks
             WHERE database IS NOT NULL GROUP BY database, mode) cnt USING (database, mode);

  ttl: 10
  tags: [cluster]
  min_version: 090400

  metrics:
    - datname:
        usage: LABEL
        description: Name of the database
    - mode:
        usage: LABEL
        description: Type of lock
    - count:
        usage: COUNTER
        description: Number of locks of corresponding mode

#-------------------------------------------------------------#
# pg_vacuuming
# pg_stat_progress_vacuum, since PostgreSQL 9.6
#-------------------------------------------------------------#

pg_vacuuming:
  query: |
    SELECT pid,
           datname,
           relid,
           relname,
           phase,
           CASE WHEN heap_blks_total > 0 THEN 1.0 * heap_blks_vacuumed / heap_blks_total ELSE 0 END AS progress
    FROM pg_stat_progress_vacuum pspv,
         LATERAL (SELECT relname FROM pg_class c WHERE c.oid = pspv.relid) n;

  ttl: 10
  tags: [cluster, skip_errors]
  min_version: 090600
  skip_errors: true
  metrics:
    - datname:
        usage: LABEL
        description: database name
    - pid:
        usage: LABEL
        description: process id of indexing table
    - relid:
        usage: DISCARD
        description: relation id of indexed table
    - relname:
        usage: LABEL
        description: relation name of indexed table
    - phase:
        usage: LABEL
        description: index building phase
    - progress:
        usage: GAUGE
        description: the actual progress
#-------------------------------------------------------------#
# pg_indexing
# pg_stat_progress_create_index, since PostgreSQL 12
#-------------------------------------------------------------#

pg_indexing:
  query: |
    SELECT datname, pid, relid, relname, phase,
           coalesce((CASE WHEN blocks_total > 0 THEN 1.0 * blocks_done / blocks_total ELSE NULL END),
                    (CASE WHEN tuples_total > 0 THEN 1.0 * tuples_done / tuples_total ELSE NULL END),
                    (CASE WHEN partitions_total > 0 THEN 1.0 * partitions_done / partitions_total ELSE NULL END),
                    (CASE WHEN lockers_total > 0 THEN 1.0 * lockers_done / lockers_total ELSE NULL END)) AS progress
    FROM pg_stat_progress_create_index pspci,
         LATERAL (SELECT relname FROM pg_class c WHERE c.oid = pspci.relid) n;

  ttl: 10
  tags: [cluster]
  min_version: 120000
  skip_errors: true
  metrics:
    - datname:
        usage: LABEL
        description: database name
    - pid:
        usage: LABEL
        description: process id of indexing table
    - relid:
        usage: DISCARD
        description: relation id of indexed table
    - relname:
        usage: LABEL
        description: relation name of indexed table
    - phase:
        usage: LABEL
        description: index building phase
    - progress:
        usage: GAUGE
        description: the actual progress

#-------------------------------------------------------------#
# pg_clustering
# pg_stat_progress_clustering, since PostgreSQL 12
#-------------------------------------------------------------#


pg_clustering:
  query: |

    SELECT pid,
           datname,
           relid,
           relname,
           phase,
           CASE WHEN heap_blks_total > 0 THEN 1.0 * heap_blks_scanned / heap_blks_total ELSE 0 END AS progress
    FROM pg_stat_progress_cluster pspc,
         LATERAL (SELECT relname FROM pg_class c WHERE c.oid = pspc.relid) n;

  ttl: 10
  tags: [cluster]
  min_version: 120000
  skip_errors: true
  metrics:
    - datname:
        usage: LABEL
        description: database name
    - pid:
        usage: LABEL
        description: process id of indexing table
    - relid:
        usage: DISCARD
        description: relation id of indexed table
    - relname:
        usage: LABEL
        description: relation name of indexed table
    - phase:
        usage: LABEL
        description: index building phase
    - progress:
        usage: GAUGE
        description: the actual progress

#-------------------------------------------------------------#
# pg_query
# require pg_stat_statements under schema monitor
#-------------------------------------------------------------#

pg_query:
  query: |
    SELECT datname,
           queryid AS query,
           sum(calls)               AS calls,
           sum(total_time)          AS total_time,
           sum(min_time)            AS min_time,
           sum(max_time)            AS max_time,
           sum(mean_time)           AS mean_time,
           sum(stddev_time)         AS stddev_time,
           sum(rows)                AS rows,
           sum(shared_blks_hit)     AS shared_blks_hit,
           sum(shared_blks_read)    AS shared_blks_read,
           sum(shared_blks_dirtied) AS shared_blks_dirtied,
           sum(shared_blks_written) AS shared_blks_written,
           sum(local_blks_hit)      AS local_blks_hit,
           sum(local_blks_read)     AS local_blks_read,
           sum(local_blks_dirtied)  AS local_blks_dirtied,
           sum(local_blks_written)  AS local_blks_written,
           sum(temp_blks_read)      AS temp_blks_read,
           sum(temp_blks_written)   AS temp_blks_written,
           sum(blk_read_time)       AS blk_read_time,
           sum(blk_write_time)      AS blk_write_time
    FROM monitor.pg_stat_statements s, LATERAL (SELECT datname FROM pg_database db WHERE db.oid = s.dbid) d
    GROUP BY datname, queryid
    ORDER BY calls DESC, total_time DESC LIMIT 20;

  ttl: 100
  tags: [cluster, extension:pg_stat_statements , schema:monitor]
  min_version: 090400
  skip_errors: true

  metrics:
    - datname:
        usage: LABEL
        description: database name
    - query:
        usage: LABEL
        description: query identifier, bigint
    - calls:
        usage: COUNTER
        description: times been executed
    - total_time:
        usage: COUNTER
        description: Total time spent in the statement, in µs
    - min_time:
        usage: GAUGE
        description: Minimum time spent in the statement, in µs
    - max_time:
        usage: GAUGE
        description: Maximum time spent in the statement, in µs
    - mean_time:
        usage: GAUGE
        description: Mean time spent in the statement, in µs
    - stddev_time:
        usage: GAUGE
        description: Population standard deviation of time spent in the statement, in µs
    - rows:
        usage: COUNTER
        description: rows retrieved or affected by the statement
    - shared_blks_hit:
        usage: COUNTER
        description: shared block cache hits by the statement
    - shared_blks_read:
        usage: COUNTER
        description: shared blocks read by the statement
    - shared_blks_dirtied:
        usage: COUNTER
        description: shared blocks dirtied by the statement
    - shared_blks_written:
        usage: COUNTER
        description: shared blocks written by the statement
    - local_blks_hit:
        usage: COUNTER
        description: local block cache hits by the statement
    - local_blks_read:
        usage: COUNTER
        description: local blocks read by the statement
    - local_blks_dirtied:
        usage: COUNTER
        description: local blocks dirtied by the statement
    - local_blks_written:
        usage: COUNTER
        description: local blocks written by the statement
    - temp_blks_read:
        usage: COUNTER
        description: temp blocks read by the statement
    - temp_blks_written:
        usage: COUNTER
        description: temp blocks written by the statement
    - blk_read_time:
        usage: COUNTER
        description: time spent reading blocks, in µs (if track_io_timing is enabled)
    - blk_write_time:
        usage: COUNTER
        description: time spent writing blocks, in µs (if track_io_timing is enabled)

#-------------------------------------------------------------#
# pg_size
# total sizes
# pg_ls_waldir and pg_ls_log_dir is available since PostgreSQL 10
#-------------------------------------------------------------#

pg_size:
  query: |
    SELECT (SELECT (coalesce(sum(size), 0)) FROM pg_ls_logdir())          AS log,
           (SELECT coalesce(sum(size), 0) FROM pg_catalog.pg_ls_waldir()) AS wal,
           (SELECT sum(pg_database_size(oid)) FROM pg_database)           AS database;

  ttl: 100
  tags: [cluster]
  min_version: 100000
  skip_errors: true
  metrics:
    - log:
        usage: GAUGE
        description: database log file size in bytes
    - wal:
        usage: GAUGE
        description: WAL file size in bytes
    - database:
        usage: GAUGE
        description: all database size in bytes

#-------------------------------------------------------------#
# pg_database
# Static database information from pg_database
#-------------------------------------------------------------#

pg_database:
  query: |
    SELECT datname,
           pg_database_size(oid)      AS size,
           age(datfrozenxid)          AS age,
           datistemplate              AS is_template,
           datallowconn               AS allow_conn,
           datconnlimit               AS conn_limit,
           datfrozenxid::TEXT::BIGINT as frozen_xid
    FROM pg_database;
  ttl: 100
  tags: [cluster]
  min_version: 100000
  max_version: 130000

  metrics:
    - datname:
        usage: LABEL
        description: database name
    - size:
        usage: GAUGE
        description: database size in bytes
    - age:
        usage: GAUGE
        description: database age calculated by age(datfrozenxid)
    - is_template:
        usage: GAUGE
        description: 1 for template db , 0 for normal db
    - allow_conn:
        usage: GAUGE
        description: 1 allow connection, 0 does not allow
    - conn_limit:
        usage: GAUGE
        description: connection limit, -1 for no limit
    - frozen_xid:
        usage: GAUGE
        description: tuple with xmin below this will always be visable (until wrap around)


#-------------------------------------------------------------#
# pg_db
# note this query will return different number of columns
# e.g: checksum_failures , checksum_last_failure is provided in 12
#-------------------------------------------------------------#


#-------------------------------------------------------------#
# This branch is for PostgreSQL 12.0+
# the view pg_stat_database in version 12 introduce two new columns:
# checksum_failures and checksum_last_failure
# https://www.postgresql.org/docs/12/monitoring-stats.html#PG-STAT-DATABASE-VIEW
#-------------------------------------------------------------#
pg_db_12:
  name: pg_db
  query: |
    SELECT d.*, c.*
    FROM pg_stat_database d,
         LATERAL (SELECT confl_tablespace, confl_lock, confl_snapshot, confl_bufferpin, confl_deadlock
                  FROM pg_stat_database_conflicts pdc WHERE pdc.datname = d.datname) c
    WHERE d.datname NOT IN ('postgres','template0','template1');

  ttl: 10
  tags: [cluster]
  min_version: 120000
  skip_errors: true
  metrics:
    - datid:
        usage: DISCARD
        description: Name of the database
    - datname:
        usage: LABEL
        description: Name of the database
    - numbackends:
        usage: GAUGE
        description: backends currently connected to this database
    - xact_commit:
        usage: COUNTER
        description: transactions in this database that have been committed
    - xact_rollback:
        usage: COUNTER
        description: transactions in this database that have been rolled back
    - blks_read:
        usage: COUNTER
        description: blocks read from disk in this database
    - blks_hit:
        usage: COUNTER
        description: blocks found in pg buffer
    - tup_returned:
        usage: COUNTER
        description: rows returned by queries in this database
    - tup_fetched:
        usage: COUNTER
        description: rows fetched by queries in this database
    - tup_inserted:
        usage: COUNTER
        description: rows inserted by queries in this database
    - tup_updated:
        usage: COUNTER
        description: rows updated by queries in this database
    - tup_deleted:
        usage: COUNTER
        description: rows deleted by queries in this database
    - conflicts:
        usage: GAUGE
        description: Number of queries canceled due to conflicts with recovery in this database. (slave only)
    - temp_files:
        usage: GAUGE
        description: Number of temporary files created by queries in this database
    - temp_bytes:
        usage: GAUGE
        description: Temporary file byte count
    - deadlocks:
        usage: GAUGE
        description: Number of deadlocks detected in this database
    - checksum_failures:
        usage: GAUGE
        description: Number of data page checksum failures detected in this database
    - checksum_last_failure:
        usage: GAUGE
        description: Time at which the last data page checksum failure was detected
    - blk_read_time:
        usage: COUNTER
        description: Time spent reading data file blocks by backends in this database, in milliseconds
    - blk_write_time:
        usage: COUNTER
        description: Time spent writing data file blocks by backends in this database, in milliseconds
    - stats_reset:
        usage: COUNTER
        description: Time at which these statistics were last reset
    - confl_tablespace:
        usage: COUNTER
        description: Number of queries in this database that have been canceled due to dropped tablespaces
    - confl_lock:
        usage: COUNTER
        description: Number of queries in this database that have been canceled due to lock timeouts
    - confl_snapshot:
        usage: COUNTER
        description: Number of queries in this database that have been canceled due to old snapshots
    - confl_bufferpin:
        usage: COUNTER
        description: Number of queries in this database that have been canceled due to pinned buffers
    - confl_deadlock:
        usage: COUNTER
        description: Number of queries in this database that have been canceled due to deadlocks



#-------------------------------------------------------------#
# This branch is for PostgreSQL 93 ~ PostgreSQL 11
# which does not have checksum related columns
#-------------------------------------------------------------#
pg_db_93_11:
  name: pg_db
  query: |
    SELECT d.*, c.*
    FROM pg_stat_database d,
         LATERAL (SELECT confl_tablespace, confl_lock, confl_snapshot, confl_bufferpin, confl_deadlock
                  FROM pg_stat_database_conflicts pdc WHERE pdc.datname = d.datname) c
    WHERE d.datname NOT IN ('postgres','template0','template1');

  ttl: 10
  tags: [cluster]
  min_version: 90300
  max_version: 120000
  skip_errors: true
  metrics:
    - datid:
        usage: DISCARD
        description: Name of the database
    - datname:
        usage: LABEL
        description: Name of the database
    - numbackends:
        usage: GAUGE
        description: backends currently connected to this database
    - xact_commit:
        usage: COUNTER
        description: transactions in this database that have been committed
    - xact_rollback:
        usage: COUNTER
        description: transactions in this database that have been rolled back
    - blks_read:
        usage: COUNTER
        description: blocks read from disk in this database
    - blks_hit:
        usage: COUNTER
        description: blocks found in pg buffer
    - tup_returned:
        usage: COUNTER
        description: rows returned by queries in this database
    - tup_fetched:
        usage: COUNTER
        description: rows fetched by queries in this database
    - tup_inserted:
        usage: COUNTER
        description: rows inserted by queries in this database
    - tup_updated:
        usage: COUNTER
        description: rows updated by queries in this database
    - tup_deleted:
        usage: COUNTER
        description: rows deleted by queries in this database
    - conflicts:
        usage: GAUGE
        description: Number of queries canceled due to conflicts with recovery in this database. (slave only)
    - temp_files:
        usage: GAUGE
        description: Number of temporary files created by queries in this database
    - temp_bytes:
        usage: GAUGE
        description: Temporary file byte count
    - deadlocks:
        usage: GAUGE
        description: Number of deadlocks detected in this database
    - blk_read_time:
        usage: COUNTER
        description: Time spent reading data file blocks by backends in this database, in milliseconds
    - blk_write_time:
        usage: COUNTER
        description: Time spent writing data file blocks by backends in this database, in milliseconds
    - stats_reset:
        usage: COUNTER
        description: Time at which these statistics were last reset
    - confl_tablespace:
        usage: COUNTER
        description: Number of queries in this database that have been canceled due to dropped tablespaces
    - confl_lock:
        usage: COUNTER
        description: Number of queries in this database that have been canceled due to lock timeouts
    - confl_snapshot:
        usage: COUNTER
        description: Number of queries in this database that have been canceled due to old snapshots
    - confl_bufferpin:
        usage: COUNTER
        description: Number of queries in this database that have been canceled due to pinned buffers
    - confl_deadlock:
        usage: COUNTER
        description: Number of queries in this database that have been canceled due to deadlocks

###############################################################
# Database Level Metrics
#   These metrics are unique for different database. So it will
#   be executed for each database even they lies in same cluster
#   note you'd better provide a datname label in your query in
#   order to get rid of name collision
###############################################################

#-------------------------------------------------------------#
# pg_class
#-------------------------------------------------------------#
pg_class:
  name: pg_class
  query: |
    SELECT CURRENT_CATALOG                                              AS datname,
           relnamespace::RegNamespace                                   AS nspname,
           relname,
           relkind,
           relpages,
           reltuples,
           CASE WHEN relkind = 'i' THEN NULL ELSE age(relfrozenxid) END AS relage,
           pg_relation_size(oid)                                        AS relsize
    FROM pg_class
    WHERE relnamespace NOT IN
          ('pg_catalog'::regnamespace::oid, 'information_schema'::regnamespace::oid, 'pg_toast'::regnamespace::oid)
      AND relkind IN ('r', 'i', 'm', 't')
  ttl: 100
  tags: [not:shard]
  min_version: 090400
  skip_errors: true
  metrics:
    - datname:
        usage: LABEL
        description: database name of this relation
    - nspname:
        usage: LABEL
        description: schema name of this relation
    - relname:
        usage: LABEL
        description: relation name of this relation
    - relkind:
        usage: LABEL
        description: relation type r-table i-index s-sequence m-mview t-toast
    - relpages:
        usage: GAUGE
        description: exact page count of this relation
    - reltuples:
        usage: GAUGE
        description: estimate relation tuples
    - relage:
        usage: GAUGE
        description: age of non-index relation
    - relsize:
        usage: GAUGE
        description: size of this relation


#-------------------------------------------------------------#
# pg_class
# for special sharding database which have tremendous tables
# this only sample from 1 or 2 specific schema
# this could relieve exporter's pressure
#-------------------------------------------------------------#
pg_class_shard:
  name: pg_class
  query: |
    SELECT CURRENT_CATALOG                                              AS datname,
           relnamespace::RegNamespace                                   AS nspname,
           relname,
           relkind,
           relpages,
           reltuples,
           CASE WHEN relkind = 'i' THEN NULL ELSE age(relfrozenxid) END AS relage,
           pg_relation_size(pc.oid)                                     AS relsize
    FROM pg_class pc
             LEFT JOIN pg_namespace pn on pc.relnamespace = pn.oid
    WHERE (nspname IN (SELECT min(nspname) FROM pg_namespace WHERE nspname LIKE 'rel_8192_%' LIMIT 1) OR nspname = 'user_search')
        AND relkind IN ('r', 'i', 'm', 't');

  ttl: 200
  tags: [shard]
  min_version: 090400
  skip_errors: true
  metrics:
    - datname:
        usage: LABEL
        description: database name of this relation
    - nspname:
        usage: LABEL
        description: schema name of this relation
    - relname:
        usage: LABEL
        description: relation name of this relation
    - relkind:
        usage: LABEL
        description: relation type r-table i-index s-sequence m-mview t-toast
    - relpages:
        usage: GAUGE
        description: exact page count of this relation
    - reltuples:
        usage: GAUGE
        description: estimate relation tuples
    - relage:
        usage: GAUGE
        description: age of non-index relation
    - relsize:
        usage: GAUGE
        description: size of this relation#-------------------------------------------------------------#
# pg_table
# note that database with tremendous of tables may suffer from
# this query. Use sampling filter or just disable it in that case
#-------------------------------------------------------------#

pg_table:
  name: pg_table
  query: |
    SELECT CURRENT_CATALOG                     AS datname,
           psut.schemaname                     AS nspname,
           psut.relname,
           seq_scan,
           seq_tup_read,
           idx_scan,
           idx_tup_fetch,
           seq_scan + idx_scan                 AS tbl_scan,
           seq_tup_read + idx_tup_fetch        AS tup_read,
           n_tup_ins,
           n_tup_upd,
           n_tup_del,
           (n_tup_ins + n_tup_upd + n_tup_del) AS n_tup_mod,
           n_tup_hot_upd,
           n_live_tup,
           n_dead_tup,
           n_mod_since_analyze,
           last_vacuum,
           last_autovacuum,
           last_analyze,
           last_autoanalyze,
           vacuum_count,
           autovacuum_count,
           analyze_count,
           autoanalyze_count,
           heap_blks_read,
           heap_blks_hit,
           idx_blks_read,
           idx_blks_hit,
           toast_blks_read,
           toast_blks_hit,
           tidx_blks_read,
           tidx_blks_hit
    FROM pg_stat_user_tables psut,
         LATERAL (SELECT * FROM pg_statio_user_tables psio WHERE psio.relid = psut.relid) p;

  ttl: 10
  tags: [not:shard]
  min_version: 090400
  skip_errors: true
  metrics:
    - datname:
        usage: LABEL
        description: database name of this relation
    - nspname:
        usage: LABEL
        description: schema name of this relation
    - relname:
        usage: LABEL
        description: relation name of this relation
    - seq_scan:
        usage: COUNTER
        description: sequential scans initiated on this table
    - seq_tup_read:
        usage: COUNTER
        description: live rows fetched by sequential scans
    - idx_scan:
        usage: COUNTER
        description: index scans initiated on this table
    - idx_tup_fetch:
        usage: COUNTER
        description: rows fetched by index scans
    - tbl_scan:
        usage: COUNTER
        description: total table scan = index scan + seq scan
    - tup_read:
        usage: COUNTER
        description: total tuples read = index fetch + seq read
    - n_tup_ins:
        usage: COUNTER
        description: rows inserted
    - n_tup_upd:
        usage: COUNTER
        description: rows updated
    - n_tup_del:
        usage: COUNTER
        description: rows deleted
    - n_tup_mod:
        usage: COUNTER
        description: rows modified (insert + update + delete)
    - n_tup_hot_upd:
        usage: COUNTER
        description: rows updated in HOT mode
    - n_live_tup:
        usage: GAUGE
        description: estimated live rows
    - n_dead_tup:
        usage: GAUGE
        description: estimated dead rows
    - n_mod_since_analyze:
        usage: GAUGE
        description: rows changed since last analyze
    - last_vacuum:
        usage: GAUGE
        description: when table was manually vacuumed last time (FULL not count)
    - last_autovacuum:
        usage: GAUGE
        description: when table was automatically vacuumed last time
    - last_analyze:
        usage: GAUGE
        description: when table was manually analyzed last time
    - last_autoanalyze:
        usage: GAUGE
        description: when table was automatically analyzed last time
    - vacuum_count:
        usage: COUNTER
        description: manual vacuum count (FULL not count)
    - autovacuum_count:
        usage: COUNTER
        description: automatic vacuum count
    - analyze_count:
        usage: COUNTER
        description: manual analyze count
    - autoanalyze_count:
        usage: COUNTER
        description: automatic analyze count
    - heap_blks_read:
        usage: COUNTER
        description: relation heap read
    - heap_blks_hit:
        usage: COUNTER
        description: relation heap hit
    - idx_blks_read:
        usage: COUNTER
        description: index read
    - idx_blks_hit:
        usage: COUNTER
        description: index hit
    - toast_blks_read:
        usage: COUNTER
        description: toast heap read
    - toast_blks_hit:
        usage: COUNTER
        description: toast heap hit
    - tidx_blks_read:
        usage: COUNTER
        description: toast index read
    - tidx_blks_hit:
        usage: COUNTER
        description: toast index hit




#-------------------------------------------------------------#
# pg_table.pg_table_shard
# this is the shard branch of pg_table
#-------------------------------------------------------------#
pg_table_shard:
  name: pg_table
  query: |
    SELECT CURRENT_CATALOG                     AS datname,
           psut.schemaname                     AS nspname,
           psut.relname,
           seq_scan,
           seq_tup_read,
           idx_scan,
           idx_tup_fetch,
           seq_scan + idx_scan                 AS tbl_scan,
           seq_tup_read + idx_tup_fetch        AS tup_read,
           n_tup_ins,
           n_tup_upd,
           n_tup_del,
           (n_tup_ins + n_tup_upd + n_tup_del) AS n_tup_mod,
           n_tup_hot_upd,
           n_live_tup,
           n_dead_tup,
           n_mod_since_analyze,
           last_vacuum,
           last_autovacuum,
           last_analyze,
           last_autoanalyze,
           vacuum_count,
           autovacuum_count,
           analyze_count,
           autoanalyze_count,
           heap_blks_read,
           heap_blks_hit,
           idx_blks_read,
           idx_blks_hit,
           toast_blks_read,
           toast_blks_hit,
           tidx_blks_read,
           tidx_blks_hit
    FROM pg_stat_user_tables psut,
         LATERAL (SELECT * FROM pg_statio_user_tables psio WHERE psio.relid = psut.relid) p
    WHERE (psut.schemaname IN (SELECT min(nspname) FROM pg_namespace WHERE nspname LIKE 'rel_8192_%' LIMIT 1) OR psut.schemaname = 'user_search');

  ttl: 10
  tags: [shard]
  min_version: 090400
  skip_errors: true
  metrics:
    - datname:
        usage: LABEL
        description: database name of this relation
    - nspname:
        usage: LABEL
        description: schema name of this relation
    - relname:
        usage: LABEL
        description: relation name of this relation
    - seq_scan:
        usage: COUNTER
        description: sequential scans initiated on this table
    - seq_tup_read:
        usage: COUNTER
        description: live rows fetched by sequential scans
    - idx_scan:
        usage: COUNTER
        description: index scans initiated on this table
    - idx_tup_fetch:
        usage: COUNTER
        description: rows fetched by index scans
    - tbl_scan:
        usage: COUNTER
        description: total table scan = index scan + seq scan
    - tup_read:
        usage: COUNTER
        description: total tuples read = index fetch + seq read
    - n_tup_ins:
        usage: COUNTER
        description: rows inserted
    - n_tup_upd:
        usage: COUNTER
        description: rows updated
    - n_tup_del:
        usage: COUNTER
        description: rows deleted
    - n_tup_mod:
        usage: COUNTER
        description: rows modified (insert + update + delete)
    - n_tup_hot_upd:
        usage: COUNTER
        description: rows updated in HOT mode
    - n_live_tup:
        usage: GAUGE
        description: estimated live rows
    - n_dead_tup:
        usage: GAUGE
        description: estimated dead rows
    - n_mod_since_analyze:
        usage: GAUGE
        description: rows changed since last analyze
    - last_vacuum:
        usage: GAUGE
        description: when table was manually vacuumed last time (FULL not count)
    - last_autovacuum:
        usage: GAUGE
        description: when table was automatically vacuumed last time
    - last_analyze:
        usage: GAUGE
        description: when table was manually analyzed last time
    - last_autoanalyze:
        usage: GAUGE
        description: when table was automatically analyzed last time
    - vacuum_count:
        usage: COUNTER
        description: manual vacuum count (FULL not count)
    - autovacuum_count:
        usage: COUNTER
        description: automatic vacuum count
    - analyze_count:
        usage: COUNTER
        description: manual analyze count
    - autoanalyze_count:
        usage: COUNTER
        description: automatic analyze count
    - heap_blks_read:
        usage: COUNTER
        description: relation heap read
    - heap_blks_hit:
        usage: COUNTER
        description: relation heap hit
    - idx_blks_read:
        usage: COUNTER
        description: index read
    - idx_blks_hit:
        usage: COUNTER
        description: index hit
    - toast_blks_read:
        usage: COUNTER
        description: toast heap read
    - toast_blks_hit:
        usage: COUNTER
        description: toast heap hit
    - tidx_blks_read:
        usage: COUNTER
        description: toast index read
    - tidx_blks_hit:
        usage: COUNTER
        description: toast index hit
#-------------------------------------------------------------#
# pg_table_size
#-------------------------------------------------------------#
pg_table_size:
  name: pg_table_size
  query: |
    SELECT CURRENT_CATALOG                       AS datname,
           nsp.nspname,
           rel.relname,
           pg_total_relation_size(rel.oid)       AS bytes,
           pg_relation_size(rel.oid)             AS relsize,
           pg_indexes_size(rel.oid)              AS indexsize,
           pg_total_relation_size(reltoastrelid) AS toastsize
    FROM pg_namespace nsp
             JOIN pg_class rel ON nsp.oid = rel.relnamespace
    WHERE nspname NOT IN ('pg_catalog', 'information_schema')
      AND rel.relkind = 'r';

  ttl: 100
  tags: [not:shard]
  min_version: 100000
  skip_errors: true
  metrics:
    - datname:
        usage: LABEL
        description: database name of this relation
    - nspname:
        usage: LABEL
        description: schema name of this relation
    - relname:
        usage: LABEL
        description: relation name of this relation
    - bytes:
        usage: GAUGE
        description: total size of this table (including toast, index, toast index)
    - relsize:
        usage: GAUGE
        description: size of this table itself (main, vm, fsm)
    - indexsize:
        usage: GAUGE
        description: size of all related indexes
    - toastsize:
        usage: GAUGE
        description: size of corresponding toast tables


#-------------------------------------------------------------#
# pg_table_size
# shard branch
#-------------------------------------------------------------#
pg_table_size_shard:
  name: pg_table_size
  query: |
    SELECT CURRENT_CATALOG                       AS datname,
           nsp.nspname,
           rel.relname,
           pg_total_relation_size(rel.oid)       AS bytes,
           pg_relation_size(rel.oid)             AS relsize,
           pg_indexes_size(rel.oid)              AS indexsize,
           pg_total_relation_size(reltoastrelid) AS toastsize
    FROM pg_namespace nsp
             JOIN pg_class rel ON nsp.oid = rel.relnamespace
    WHERE rel.relkind = 'r' AND
          (nsp.nspname IN (SELECT min(nspname) FROM pg_namespace WHERE nspname LIKE 'rel_8192_%' LIMIT 1) OR nsp.nspname = 'user_search');

  ttl: 200
  tags: [shard]
  min_version: 100000
  skip_errors: true
  metrics:
    - datname:
        usage: LABEL
        description: database name of this relation
    - nspname:
        usage: LABEL
        description: schema name of this relation
    - relname:
        usage: LABEL
        description: relation name of this relation
    - bytes:
        usage: GAUGE
        description: total size of this table (including toast, index, toast index)
    - relsize:
        usage: GAUGE
        description: size of this table itself (main, vm, fsm)
    - indexsize:
        usage: GAUGE
        description: size of all related indexes
    - toastsize:
        usage: GAUGE
        description: size of corresponding toast tables

#-------------------------------------------------------------#
# pg_table_bloat
# estimated bloat
#-------------------------------------------------------------#
pg_table_bloat:
  name: pg_table_bloat
  query: |
    SELECT CURRENT_CATALOG AS datname, nspname, relname , bs * tblpages AS size,
           CASE WHEN tblpages - est_tblpages_ff > 0 THEN (tblpages - est_tblpages_ff)/tblpages::FLOAT ELSE 0 END AS ratio
    FROM (
             SELECT ceil( reltuples / ( (bs-page_hdr)*fillfactor/(tpl_size*100) ) ) + ceil( toasttuples / 4 ) AS est_tblpages_ff,
                    tblpages, fillfactor, bs, tblid, nspname, relname, is_na
             FROM (
                      SELECT
                          ( 4 + tpl_hdr_size + tpl_data_size + (2 * ma)
                              - CASE WHEN tpl_hdr_size % ma = 0 THEN ma ELSE tpl_hdr_size % ma END
                              - CASE WHEN ceil(tpl_data_size)::INT % ma = 0 THEN ma ELSE ceil(tpl_data_size)::INT % ma END
                              ) AS tpl_size, (heappages + toastpages) AS tblpages, heappages,
                          toastpages, reltuples, toasttuples, bs, page_hdr, tblid, nspname, relname, fillfactor, is_na
                      FROM (
                               SELECT
                                   tbl.oid AS tblid, ns.nspname , tbl.relname, tbl.reltuples,
                                   tbl.relpages AS heappages, coalesce(toast.relpages, 0) AS toastpages,
                                   coalesce(toast.reltuples, 0) AS toasttuples,
                                   coalesce(substring(array_to_string(tbl.reloptions, ' ') FROM 'fillfactor=([0-9]+)')::smallint, 100) AS fillfactor,
                                   current_setting('block_size')::numeric AS bs,
                                   CASE WHEN version()~'mingw32' OR version()~'64-bit|x86_64|ppc64|ia64|amd64' THEN 8 ELSE 4 END AS ma,
                                   24 AS page_hdr,
                                   23 + CASE WHEN MAX(coalesce(s.null_frac,0)) > 0 THEN ( 7 + count(s.attname) ) / 8 ELSE 0::int END
                                       + CASE WHEN bool_or(att.attname = 'oid' and att.attnum < 0) THEN 4 ELSE 0 END AS tpl_hdr_size,
                                   sum( (1-coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 0) ) AS tpl_data_size,
                                   bool_or(att.atttypid = 'pg_catalog.name'::regtype)
                                       OR sum(CASE WHEN att.attnum > 0 THEN 1 ELSE 0 END) <> count(s.attname) AS is_na
                               FROM pg_attribute AS att
                                        JOIN pg_class AS tbl ON att.attrelid = tbl.oid
                                        JOIN pg_namespace AS ns ON ns.oid = tbl.relnamespace
                                        LEFT JOIN pg_stats AS s ON s.schemaname=ns.nspname AND s.tablename = tbl.relname AND s.inherited=false AND s.attname=att.attname
                                        LEFT JOIN pg_class AS toast ON tbl.reltoastrelid = toast.oid
                               WHERE NOT att.attisdropped AND tbl.relkind = 'r' AND nspname NOT IN ('pg_catalog','information_schema')
                               GROUP BY 1,2,3,4,5,6,7,8,9,10
                           ) AS s
                  ) AS s2
         ) AS s3
    WHERE NOT is_na;


  ttl: 100
  tags: [not:shard]
  min_version: 090400
  skip_errors: true

  metrics:
    - datname:
        usage: LABEL
        description: database name of this table
    - nspname:
        usage: LABEL
        description: schema name of this table
    - relname:
        usage: LABEL
        description: relation name of this table
    - size:
        usage: GAUGE
        description: total size in bytes of this table
    - ratio:
        usage: GAUGE
        description: estimated bloat ratio of this table, 0~1



#-------------------------------------------------------------#
# pg_table_bloat
# shard branch
#-------------------------------------------------------------#
pg_table_bloat_shard:
  name: pg_table_bloat
  query: |
    SELECT CURRENT_CATALOG AS datname, nspname, relname , bs * tblpages AS size,
           CASE WHEN tblpages - est_tblpages_ff > 0 THEN (tblpages - est_tblpages_ff)/tblpages::FLOAT ELSE 0 END AS ratio
    FROM (
             SELECT ceil( reltuples / ( (bs-page_hdr)*fillfactor/(tpl_size*100) ) ) + ceil( toasttuples / 4 ) AS est_tblpages_ff,
                    tblpages, fillfactor, bs, tblid, nspname, relname, is_na
             FROM (
                      SELECT
                          ( 4 + tpl_hdr_size + tpl_data_size + (2 * ma)
                              - CASE WHEN tpl_hdr_size % ma = 0 THEN ma ELSE tpl_hdr_size % ma END
                              - CASE WHEN ceil(tpl_data_size)::INT % ma = 0 THEN ma ELSE ceil(tpl_data_size)::INT % ma END
                              ) AS tpl_size, (heappages + toastpages) AS tblpages, heappages,
                          toastpages, reltuples, toasttuples, bs, page_hdr, tblid, nspname, relname, fillfactor, is_na
                      FROM (
                               SELECT
                                   tbl.oid AS tblid, ns.nspname , tbl.relname, tbl.reltuples,
                                   tbl.relpages AS heappages, coalesce(toast.relpages, 0) AS toastpages,
                                   coalesce(toast.reltuples, 0) AS toasttuples,
                                   coalesce(substring(array_to_string(tbl.reloptions, ' ') FROM 'fillfactor=([0-9]+)')::smallint, 100) AS fillfactor,
                                   current_setting('block_size')::numeric AS bs,
                                   CASE WHEN version()~'mingw32' OR version()~'64-bit|x86_64|ppc64|ia64|amd64' THEN 8 ELSE 4 END AS ma,
                                   24 AS page_hdr,
                                   23 + CASE WHEN MAX(coalesce(s.null_frac,0)) > 0 THEN ( 7 + count(s.attname) ) / 8 ELSE 0::int END
                                       + CASE WHEN bool_or(att.attname = 'oid' and att.attnum < 0) THEN 4 ELSE 0 END AS tpl_hdr_size,
                                   sum( (1-coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 0) ) AS tpl_data_size,
                                   bool_or(att.atttypid = 'pg_catalog.name'::regtype)
                                       OR sum(CASE WHEN att.attnum > 0 THEN 1 ELSE 0 END) <> count(s.attname) AS is_na
                               FROM pg_attribute AS att
                                        JOIN pg_class AS tbl ON att.attrelid = tbl.oid
                                        JOIN pg_namespace AS ns ON ns.oid = tbl.relnamespace
                                        LEFT JOIN pg_stats AS s ON s.schemaname=ns.nspname AND s.tablename = tbl.relname AND s.inherited=false AND s.attname=att.attname
                                        LEFT JOIN pg_class AS toast ON tbl.reltoastrelid = toast.oid
                               WHERE NOT att.attisdropped AND tbl.relkind = 'r' AND (nspname IN (SELECT min(nspname) FROM pg_namespace WHERE nspname LIKE 'rel_8192_%' LIMIT 1) OR nspname = 'user_search')
                               GROUP BY 1,2,3,4,5,6,7,8,9,10
                           ) AS s
                  ) AS s2
         ) AS s3
    WHERE NOT is_na;


  ttl: 200
  tags: [shard]
  min_version: 090400
  skip_errors: true

  metrics:
    - datname:
        usage: LABEL
        description: database name of this table
    - nspname:
        usage: LABEL
        description: schema name of this table
    - relname:
        usage: LABEL
        description: relation name of this table
    - size:
        usage: GAUGE
        description: total size in bytes of this table
    - ratio:
        usage: GAUGE
        description: estimated bloat ratio of this table, 0~1
#-------------------------------------------------------------#
# pg_index
# note that database with tremendous of tables may suffer from
# this query. Use sampling filter or just disable it in that case
# https://www.postgresql.org/docs/9.4/monitoring-stats.html#PG-STATIO-ALL-INDEXES-VIEW
# https://www.postgresql.org/docs/9.4/monitoring-stats.html#PG-STAT-ALL-INDEXES-VIEW
#-------------------------------------------------------------#

pg_index:
  name: pg_index
  query: |
    SELECT CURRENT_CATALOG AS datname,
           schemaname      AS nspname,
           indexrelname    AS relname,
           idx_scan,
           idx_tup_read,
           idx_tup_fetch,
           idx_blks_read,
           idx_blks_hit
    FROM pg_stat_user_indexes psui,
         LATERAL (SELECT idx_blks_read, idx_blks_hit FROM pg_statio_user_indexes psio
         WHERE psio.indexrelid = psui.indexrelid) p2;

  ttl: 10
  tags: [not:shard]
  min_version: 090400
  skip_errors: true

  metrics:
    - datname:
        usage: LABEL
        description: database name of this relation
    - nspname:
        usage: LABEL
        description: schema name of this relation
    - relname:
        usage: LABEL
        description: relation name of this relation
    - idx_scan:
        usage: COUNTER
        description: index scans initiated on this index
    - idx_tup_read:
        usage: COUNTER
        description: index entries returned by scans on this index
    - idx_tup_fetch:
        usage: COUNTER
        description: live table rows fetched by simple index scans using this index
    - idx_blks_read:
        usage: COUNTER
        description: blocks been read from disk of this index
    - idx_blks_hit:
        usage: COUNTER
        description: blocks hit from cache of this index

#-------------------------------------------------------------#
# pg_index
# shard branch
#-------------------------------------------------------------#

pg_index_shard:
  name: pg_index
  query: |
    SELECT CURRENT_CATALOG AS datname,
           schemaname      AS nspname,
           indexrelname    AS relname,
           idx_scan,
           idx_tup_read,
           idx_tup_fetch,
           idx_blks_read,
           idx_blks_hit
    FROM pg_stat_user_indexes psui,
         LATERAL (SELECT idx_blks_read, idx_blks_hit FROM pg_statio_user_indexes psio WHERE psio.indexrelid = psui.indexrelid) p2
    WHERE psui.schemaname IN (SELECT min(nspname) FROM pg_namespace WHERE nspname LIKE 'rel_8192_%' LIMIT 1) OR psui.schemaname = 'user_search';

  ttl: 10
  tags: [shard]
  min_version: 090400
  skip_errors: true
  metrics:
    - datname:
        usage: LABEL
        description: database name of this relation
    - nspname:
        usage: LABEL
        description: schema name of this relation
    - relname:
        usage: LABEL
        description: relation name of this relation
    - idx_scan:
        usage: COUNTER
        description: index scans initiated on this index
    - idx_tup_read:
        usage: COUNTER
        description: index entries returned by scans on this index
    - idx_tup_fetch:
        usage: COUNTER
        description: live table rows fetched by simple index scans using this index
    - idx_blks_read:
        usage: COUNTER
        description: blocks been read from disk of this index
    - idx_blks_hit:
        usage: COUNTER
        description: blocks hit from cache of this index

#-------------------------------------------------------------#
# pg_index_bloat
# bloat index ratio, not all index are included (btree only)
#-------------------------------------------------------------#
pg_index_bloat:
  name: pg_index_bloat
  query: |
    SELECT CURRENT_CATALOG AS datname, nspname, idxname AS relname, relpages::BIGINT * bs AS size,
           COALESCE((relpages - ( reltuples * (6 + ma - (CASE WHEN index_tuple_hdr % ma = 0 THEN ma ELSE index_tuple_hdr % ma END)
                                + nulldatawidth + ma - (CASE WHEN nulldatawidth % ma = 0 THEN ma ELSE nulldatawidth % ma END))
                       / (bs - pagehdr)::FLOAT  + 1 )), 0) / relpages::FLOAT AS ratio
    FROM (
         SELECT nspname,
                idxname,
                reltuples,
                relpages,
                current_setting('block_size')::INTEGER                                                               AS bs,
                (CASE WHEN version() ~ 'mingw32' OR version() ~ '64-bit|x86_64|ppc64|ia64|amd64' THEN 8 ELSE 4 END)  AS ma,
                24                                                                                                   AS pagehdr,
                (CASE WHEN max(COALESCE(pg_stats.null_frac, 0)) = 0 THEN 2 ELSE 6 END)                               AS index_tuple_hdr,
                sum((1.0 - COALESCE(pg_stats.null_frac, 0.0)) *
                    COALESCE(pg_stats.avg_width, 1024))::INTEGER                                                     AS nulldatawidth
         FROM pg_attribute
                  JOIN (
             SELECT pg_namespace.nspname,
                    ic.relname                                                   AS idxname,
                    ic.reltuples,
                    ic.relpages,
                    pg_index.indrelid,
                    pg_index.indexrelid,
                    tc.relname                                                   AS tablename,
                    regexp_split_to_table(pg_index.indkey::TEXT, ' ') :: INTEGER AS attnum,
                    pg_index.indexrelid                                          AS index_oid
             FROM pg_index
                      JOIN pg_class ic ON pg_index.indexrelid = ic.oid
                      JOIN pg_class tc ON pg_index.indrelid = tc.oid
                      JOIN pg_namespace ON pg_namespace.oid = ic.relnamespace
                      JOIN pg_am ON ic.relam = pg_am.oid
             WHERE pg_am.amname = 'btree' AND ic.relpages > 0 AND nspname NOT IN ('pg_catalog', 'information_schema')
         ) ind_atts ON pg_attribute.attrelid = ind_atts.indexrelid AND pg_attribute.attnum = ind_atts.attnum
                  JOIN pg_stats ON pg_stats.schemaname = ind_atts.nspname
                                       AND ((pg_stats.tablename = ind_atts.tablename AND pg_stats.attname = pg_get_indexdef(pg_attribute.attrelid, pg_attribute.attnum, TRUE))
                                                OR (pg_stats.tablename = ind_atts.idxname AND pg_stats.attname = pg_attribute.attname))
         WHERE pg_attribute.attnum > 0
         GROUP BY 1, 2, 3, 4, 5, 6
     ) est;

  ttl: 100
  tags: [not:shard]
  min_version: 090400
  skip_errors: true
  metrics:
    - datname:
        usage: LABEL
        description: database name of this index
    - nspname:
        usage: LABEL
        description: schema name of this index
    - relname:
        usage: LABEL
        description: relation name of this index relation
    - size:
        usage: GAUGE
        description: total size in bytes of this index
    - ratio:
        usage: GAUGE
        description: estimated bloat ratio of this index, 0~1



#-------------------------------------------------------------#
# pg_index_bloat
# shard branch
#-------------------------------------------------------------#
pg_index_bloat_shard:
  name: pg_index_bloat
  query: |
    SELECT CURRENT_CATALOG AS datname, nspname, idxname AS relname, relpages::BIGINT * bs AS size,
           COALESCE((relpages - ( reltuples * (6 + ma - (CASE WHEN index_tuple_hdr % ma = 0 THEN ma ELSE index_tuple_hdr % ma END)
                                                   + nulldatawidth + ma - (CASE WHEN nulldatawidth % ma = 0 THEN ma ELSE nulldatawidth % ma END))
                                      / (bs - pagehdr)::FLOAT  + 1 )), 0) / relpages::FLOAT AS ratio
    FROM (
             SELECT nspname,
                    idxname,
                    reltuples,
                    relpages,
                    current_setting('block_size')::INTEGER                                                               AS bs,
                    (CASE WHEN version() ~ 'mingw32' OR version() ~ '64-bit|x86_64|ppc64|ia64|amd64' THEN 8 ELSE 4 END)  AS ma,
                    24                                                                                                   AS pagehdr,
                    (CASE WHEN max(COALESCE(pg_stats.null_frac, 0)) = 0 THEN 2 ELSE 6 END)                               AS index_tuple_hdr,
                    sum((1.0 - COALESCE(pg_stats.null_frac, 0.0)) *
                        COALESCE(pg_stats.avg_width, 1024))::INTEGER                                                     AS nulldatawidth
             FROM pg_attribute
                      JOIN (
                 SELECT pg_namespace.nspname,
                        ic.relname                                                   AS idxname,
                        ic.reltuples,
                        ic.relpages,
                        pg_index.indrelid,
                        pg_index.indexrelid,
                        tc.relname                                                   AS tablename,
                        regexp_split_to_table(pg_index.indkey::TEXT, ' ') :: INTEGER AS attnum,
                        pg_index.indexrelid                                          AS index_oid
                 FROM pg_index
                          JOIN pg_class ic ON pg_index.indexrelid = ic.oid
                          JOIN pg_class tc ON pg_index.indrelid = tc.oid
                          JOIN pg_namespace ON pg_namespace.oid = ic.relnamespace
                          JOIN pg_am ON ic.relam = pg_am.oid
                 WHERE pg_am.amname = 'btree' AND ic.relpages > 0
                   AND (nspname IN (SELECT min(nspname) FROM pg_namespace WHERE nspname LIKE 'rel_8192_%' LIMIT 1) OR nspname = 'user_search')
             ) ind_atts ON pg_attribute.attrelid = ind_atts.indexrelid AND pg_attribute.attnum = ind_atts.attnum
                      JOIN pg_stats ON pg_stats.schemaname = ind_atts.nspname
                 AND ((pg_stats.tablename = ind_atts.tablename AND pg_stats.attname = pg_get_indexdef(pg_attribute.attrelid, pg_attribute.attnum, TRUE))
                     OR (pg_stats.tablename = ind_atts.idxname AND pg_stats.attname = pg_attribute.attname))
             WHERE pg_attribute.attnum > 0
             GROUP BY 1, 2, 3, 4, 5, 6
         ) est;

  ttl: 200
  tags: [shard]
  min_version: 090400
  skip_errors: true
  metrics:
    - datname:
        usage: LABEL
        description: database name of this index
    - nspname:
        usage: LABEL
        description: schema name of this index
    - relname:
        usage: LABEL
        description: relation name of this index relation
    - size:
        usage: GAUGE
        description: total size in bytes of this index
    - ratio:
        usage: GAUGE
        description: estimated bloat ratio of this index, 0~1

#-------------------------------------------------------------#
# pg_func
# note that database with tremendous of tables may suffer from
# this query. Use sampling filter or just disable it in that case
#-------------------------------------------------------------#

pg_func:
  name: pg_func
  query: |
    SELECT CURRENT_CATALOG AS datname,
           schemaname      AS nspname,
           funcname,
           funcid,
           calls,
           total_time,
           self_time
    FROM pg_stat_user_functions;

  ttl: 10
  tags: [not:shard]
  min_version: 090400
  skip_errors: true
  metrics:
    - datname:
        usage: LABEL
        description: database name of this function
    - nspname:
        usage: LABEL
        description: schema name of this function
    - funcname:
        usage: LABEL
        description: function name of this function
    - funcid:
        usage: LABEL
        description: function id, note that function could override
    - calls:
        usage: COUNTER
        description: how many times this function has been called
    - total_time:
        usage: COUNTER
        description: how much time spent in this function and it's child function, in ms
    - self_time:
        usage: COUNTER
        description: how much time spent in this function itself (other func not included), in ms



#-------------------------------------------------------------#
# pg_func
# shard branch
#-------------------------------------------------------------#

pg_func_shard:
  name: pg_func
  query: |
    SELECT CURRENT_CATALOG AS datname,
           schemaname      AS nspname,
           funcname,
           funcid,
           calls,
           total_time,
           self_time
    FROM pg_stat_user_functions
    WHERE schemaname IN (SELECT min(nspname) FROM pg_namespace WHERE nspname LIKE 'rel_8192_%' LIMIT 1) OR schemaname = 'user_search';

  ttl: 10
  tags: [shard]
  min_version: 090400
  skip_errors: true
  metrics:
    - datname:
        usage: LABEL
        description: database name of this function
    - nspname:
        usage: LABEL
        description: schema name of this function
    - funcname:
        usage: LABEL
        description: function name of this function
    - funcid:
        usage: LABEL
        description: function id, note that function could override
    - calls:
        usage: COUNTER
        description: how many times this function has been called
    - total_time:
        usage: COUNTER
        description: how much time spent in this function and it's child function, in ms
    - self_time:
        usage: COUNTER
        description: how much time spent in this function itself (other func not included), in ms

#-------------------------------------------------------------#
# pgbouncer_list
# show PgBouncer lists
#-------------------------------------------------------------#

pgbouncer_list:
  query: |
    SHOW LISTS;

  ttl: 5
  tags: [pgbouncer]
  min_version: 10800
  metrics:
    - list:
        usage: LABEL
        description: pgbouncer internal list name
    - items:
        usage: GAUGE
        description: count of curresponding pgbouncer object
#-------------------------------------------------------------#
# pgbouncer_stat
# this is a special query for pgbouncer
#-------------------------------------------------------------#

pgbouncer_stat:
  query: |
    SHOW STATS;
  ttl: 5
  tags: [pgbouncer]
  min_version: 10800
  metrics:
    - database:
        usage: LABEL
        rename: datname
        description: database name of this relation
    - total_xact_count:
        usage: GAUGE
        description: total tr
    - total_query_count:
        usage: GAUGE
        description: relation name of this relation
    - total_received:
        usage: COUNTER
        description: how many times this function has been called
    - total_sent:
        usage: COUNTER
        description: how much time spent in this function and it's child function, in ms
    - total_xact_time:
        usage: COUNTER
        description: how much time spent in this function itself (other func not included), in ms
    - total_query_time:
        usage: COUNTER
        description: how many times this function has been called
    - total_wait_time:
        usage: COUNTER
        description: how much time spent in this function and it's child function, in ms
    - avg_xact_count:
        usage: GAUGE
        description: how much time spent in this function itself (other func not included), in ms
    - avg_query_count:
        usage: GAUGE
        description: how many times this function has been called
    - avg_recv:
        usage: GAUGE
        description: how much time spent in this function and it's child function, in ms
    - avg_sent:
        usage: GAUGE
        description: how much time spent in this function itself (other func not included), in ms
    - avg_xact_time:
        usage: GAUGE
        description: how many times this function has been called
    - avg_query_time:
        usage: GAUGE
        description: how much time spent in this function and it's child function, in ms
    - avg_wait_time:
        usage: GAUGE
        description: how much time spent in this function itself (other func not included), in ms
#-------------------------------------------------------------#
# pgbouncer_database
# show database stats
#-------------------------------------------------------------#

pgbouncer_database:
  query: |
    SHOW DATABASES;

  ttl: 5
  tags: [pgbouncer]
  min_version: 10800
  metrics:
    - name:
        usage: LABEL
        rename: datname
        description: name of configured database entry
    - host:
        usage: LABEL
        description: host pgbouncer connects to
    - port:
        usage: LABEL
        description:  port pgbouncer connects to
    - database:
        usage: LABEL
        rename: real_datname
        description: actual database name pgbouncer connects to
    - force_user:
        usage: DISCARD
    - pool_size:
        usage: COUNTER
        description: maximum number of server connections
    - reserve_pool:
        usage: GAUGE
        description: maximum number of additional connections for this database
    - pool_mode:
        usage: DISCARD
    - max_connections:
        usage: GAUGE
        description: maximum number of allowed connections for this database
    - current_connections:
        usage: GAUGE
        description: current number of connections for this database
    - paused:
        usage: GAUGE
        description: 1 if this database is currently paused, else 0
    - disabled:
        usage: GAUGE
        description: 1 if this database is currently disabled, else 0
#-------------------------------------------------------------#
# pgbouncer_pool
# pgbouncer pool level stats, pool is a database-user pair
#-------------------------------------------------------------#

pgbouncer_pool:
  query: |
    SHOW POOLS;

  ttl: 5
  tags: [pgbouncer]
  min_version: 10800
  metrics:
    - database:
        usage: LABEL
        rename: datname
        description: database name of this relation
    - user:
        usage: LABEL
        description: user
    - cl_active:
        usage: GAUGE
        rename: active_clients
        description: client connections that are linked to server connection and can process queries
    - cl_waiting:
        usage: GAUGE
        rename: waiting_clients
        description: client connections that have sent queries but have not yet got a server connection
    - sv_active:
        usage: GAUGE
        rename: active_servers
        description: server connections that are linked to a client
    - sv_idle:
        usage: GAUGE
        rename: idle_servers
        description: server connections that are unused and immediately usable for client queries
    - sv_used:
        usage: GAUGE
        rename: used_servers
        description: server connections that have been idle for more than server_check_delay (means have to run check query)
    - sv_tested:
        usage: GAUGE
        rename: tested_servers
        description: server connections that are currently running reset or check query
    - sv_login:
        usage: GAUGE
        rename: login_servers
        description:  server connections currently in the process of logging in
    - maxwait:
        usage: GAUGE
        description: how long the first(oldest) client in the queue has waited, in seconds, key metric
    - maxwait_us:
        usage: GAUGE
        description: microsecond part of the maximum waiting time.
    - pool_mode:
        usage: DISCARD
        description: the pooling mode in use

