###############################################################
# PostgreSQL Metric Queries
# Author:   Vonng (fengruohang@outlook.com)
# Desc  :   pg_exporter metrics config files
# Ver   :   PostgreSQL 10, 11, 12
# Mtime :   2019-12-05
###############################################################



###############################################################
# Cluster Level Metrics
#   These are cluster level metrics (visible from all database)
#   cluster queries will not execute for each database of the
#   same cluster
###############################################################

#-------------------------------------------------------------#
# pg
# generic
#-------------------------------------------------------------#
- pg:
    query: "SELECT pg_is_in_recovery() AS is_in_recovery,
                   pg_is_in_backup()   AS is_in_backup,
                   (CASE WHEN pg_is_in_recovery() THEN pg_last_wal_replay_lsn()  ELSE pg_current_wal_lsn() END) - '0/0' AS lsn,
                   (CASE WHEN pg_is_in_recovery() THEN pg_last_wal_receive_lsn() ELSE NULL END)                 - '0/0' AS receive_lsn,
                   (CASE WHEN pg_is_in_recovery() THEN pg_last_wal_replay_lsn() ELSE NULL END)                  - '0/0' AS replay_lsn,
                   (CASE WHEN NOT pg_is_in_recovery() THEN pg_current_wal_insert_lsn() ELSE NULL END)           - '0/0' AS insert_lsn,
                   (CASE WHEN NOT pg_is_in_recovery() THEN pg_current_wal_lsn() ELSE NULL END)                  - '0/0' AS write_lsn,
                   (CASE WHEN NOT pg_is_in_recovery() THEN pg_current_wal_flush_lsn()  ELSE NULL END)           - '0/0' AS flush_lsn,
                   extract(EPOCH FROM now() - pg_postmaster_start_time())                                               AS uptime,
                   extract(EPOCH FROM now() - pg_conf_load_time())                                                      AS conf_reload_time,
                   extract(EPOCH FROM now() - pg_backup_start_time())                                                   AS backup_time,
                   (CASE WHEN pg_is_in_recovery() THEN (CASE WHEN pg_last_wal_receive_lsn() = pg_last_wal_replay_lsn() THEN 0
                       ELSE EXTRACT(EPOCH FROM now() - pg_last_xact_replay_timestamp()) END) ELSE NULL END)             AS lag,
                   (CASE WHEN pg_is_in_recovery() THEN extract(EPOCH FROM pg_last_xact_replay_timestamp()) ELSE NULL END) AS last_replay_time;"
    options:
      min_version: 100000
      max_version: 130000
      cluster_level: true
      skip_primary: false
      skip_standby: false
      skip_error: false
      cache_seconds: 10
      timeout: 0
    metrics:
      - is_in_recovery:
          usage: "GAUGE"
          description: "1 for standby and 0 for primary"
      - is_in_backup:
          usage: "GAUGE"
          description: "1 if backup is in progress"
      - lsn:
          usage: "COUNTER"
          description: "log sequence number, write location for primary, replay location for standby"
      - receive_lsn:
          usage: "COUNTER"
          description: "standby only, location of wal synced to disk"
      - replay_lsn:
          usage: "COUNTER"
          description: "standby only, location of wal applied"
      - insert_lsn:
          usage: "COUNTER"
          description: "primary only, location of current wal inserting"
      - write_lsn:
          usage: "COUNTER"
          description: "primary only, location of current wal writing"
      - flush_lsn:
          usage: "COUNTER"
          description: "primary only, location of current wal syncing"
      - uptime:
          usage: "GAUGE"
          description: "seconds since postmaster start"
      - conf_reload_time:
          usage: "GAUGE"
          description: "seconds since last configuration reload"
      - backup_time:
          usage: "GAUGE"
          description: "seconds since current backup start. null if don't have one"
      - lag:
          usage: "GAUGE"
          description: "replication lag in seconds from view of standby server"
      - last_replay_time:
          usage: "GAUGE"
          description: "time when last transaction been replayed"


#-------------------------------------------------------------#
# pg_repl
# replication
#-------------------------------------------------------------#
- pg_repl:
    query: "SELECT pid                                                                                                 as pid,
                   client_addr,
                   application_name,
                   state,
                   (CASE WHEN pg_is_in_recovery() THEN pg_last_wal_replay_lsn() ELSE pg_current_wal_lsn() END) - '0/0' AS lsn,
                   sent_lsn - '0/0'                                                                                    AS sent_lsn,
                   write_lsn - '0/0'                                                                                   AS write_lsn,
                   flush_lsn - '0/0'                                                                                   AS flush_lsn,
                   replay_lsn - '0/0'                                                                                  AS replay_lsn,
                   extract(EPOCH FROM write_lag)                                                                       AS write_lag,
                   extract(EPOCH FROM flush_lag)                                                                       AS flush_lag,
                   extract(EPOCH FROM replay_lag)                                                                      AS replay_lag,
                   extract(EPOCH FROM now() - backend_start)                                                           AS backend_uptime,
                   backend_xmin::TEXT::BIGINT                                                                          as backend_xmin,
                   sync_priority
            FROM pg_stat_replication;"
    options:
      min_version: 100000
      max_version: 130000
      cluster_level: true
      skip_primary: false
      skip_standby: false
      skip_error: false
      cache_seconds: 10
      timeout: 0
    metrics:
      - pid:
          usage: "LABEL"
          description: "walsender pid, unique"
      - client_addr:
          usage: "LABEL"
          description: "client address of wal receiver"
      - application_name:
          usage: "LABEL"
          description: "application name of standby"
      - state:
          usage: "LABEL"
          description: "replication state: startup|catchup|streaming|backup|stopping"
      - lsn:
          usage: "COUNTER"
          description: "current log position on this server"
      - sent_lsn:
          usage: "COUNTER"
          description: "last log position sent to this standby server"
      - write_lsn:
          usage: "COUNTER"
          description: "last log position written to disk by this standby server"
      - flush_lsn:
          usage: "COUNTER"
          description: "last log position flushed to disk by this standby server"
      - replay_lsn:
          usage: "COUNTER"
          description: "last log position replayed into the database on this standby server"
      - write_lag:
          usage: "GAUGE"
          description: "latest ACK lsn diff with write (sync-remote-write lag)"
      - flush_lag:
          usage: "GAUGE"
          description: "latest ACK lsn diff with flush (sync-remote-flush lag)"
      - replay_lag:
          usage: "GAUGE"
          description: "latest ACK lsn diff with replay (sync-remote-apply lag)"
      - backend_uptime:
          usage: "GAUGE"
          description: "how long since standby connect to this server"
      - backend_xmin:
          usage: "GAUGE"
          description: "this standby's xmin horizon reported by hot_standby_feedback."
      - sync_priority:
          usage: "GAUGE"
          description: "priority of being chosen as synchronous standby"


#-------------------------------------------------------------#
# pg_slot
# replication slots
#-------------------------------------------------------------#
- pg_slot:
    query: "SELECT slot_name,
               database                    AS datname,
               active,
               xmin::TEXT::BIGINT          AS xmin,
               catalog_xmin::TEXT::BIGINT  AS catalog_xmin,
               restart_lsn - '0/0'         AS restart_lsn,
               confirmed_flush_lsn - '0/0' AS confirm_lsn,
               (CASE WHEN pg_is_in_recovery() THEN pg_last_wal_replay_lsn() ELSE pg_current_wal_lsn() END) - restart_lsn
                                           AS retained_bytes
        FROM pg_replication_slots;"
    options:
      min_version: 100000
      max_version: 130000
      cluster_level: true
      skip_primary: false
      skip_standby: false
      skip_error: false
      cache_seconds: 10
      timeout: 0
    metrics:
      - slot_name:
          usage: "LABEL"
          description: "Name of the replication slot"
      - datname:
          usage: "LABEL"
          description: "associated database name, logical replication slot only, null for physical slot"
      - active:
          usage: "GAUGE"
          description: "whether the slot is currently being used"
      - xmin:
          usage: "GAUGE"
          description: "oldest txid that this slot needs the database to retain"
      - catalog_xmin:
          usage: "GAUGE"
          description: "oldest txid that this slot needs the database to retain for catalog"
      - restart_lsn:
          usage: "COUNTER"
          description: "lsn that needs retain, wal after that will be kept"
      - confirm_lsn:
          usage: "COUNTER"
          description: "lsn that confirmed by logical standby, null for physical slot"
      - retained_bytes:
          usage: "GAUGE"
          description: "bytes retained for this slot"


#-------------------------------------------------------------#
# pg_bgwriter
# background writer
#-------------------------------------------------------------#
- pg_bgwriter:
    query: "  SELECT checkpoints_timed, checkpoints_req, checkpoint_write_time, checkpoint_sync_time,
                  buffers_checkpoint, buffers_clean, buffers_backend,
                  maxwritten_clean, buffers_backend_fsync, buffers_alloc, stats_reset
              FROM pg_stat_bgwriter;"
    options:
      min_version: 100000
      max_version: 130000
      cluster_level: true
      skip_primary: false
      skip_standby: false
      skip_error: false
      cache_seconds: 10
      timeout: 0
    metrics:
      - checkpoints_timed:
          usage: "COUNTER"
          description: "scheduled checkpoints that have been performed"
      - checkpoints_req:
          usage: "COUNTER"
          description: "requested checkpoints that have been performed"
      - checkpoint_write_time:
          usage: "COUNTER"
          description: "time spending on writing files to disk, in µs"
      - checkpoint_sync_time:
          usage: "COUNTER"
          description: "time spending on syncing files to disk, in µs"
      - buffers_checkpoint:
          usage: "COUNTER"
          description: "buffers written during checkpoints"
      - buffers_clean:
          usage: "COUNTER"
          description: "buffers written by the background writer"
      - buffers_backend:
          usage: "COUNTER"
          description: "buffers written directly by a backend"
      - maxwritten_clean:
          usage: "COUNTER"
          description: "times that bgwriter stopped a cleaning scan"
      - buffers_backend_fsync:
          usage: "COUNTER"
          description: "times a backend had to execute its own fsync"
      - buffers_alloc:
          usage: "COUNTER"
          description: "buffers allocated"
      - stats_reset:
          usage: "COUNTER"
          description: "time when statistics were last reset"


#-------------------------------------------------------------#
# pg_wal
# wal size
#-------------------------------------------------------------#
- pg_wal:
    query: "SELECT coalesce(sum(size),0) AS size FROM pg_catalog.pg_ls_waldir();"
    options:
      min_version: 100000
      max_version: 130000
      cluster_level: true
      skip_primary: false
      skip_standby: false
      skip_error: false
      cache_seconds: 100
      timeout: 0
    metrics:
      - size:
          usage: "GAUGE"
          description: "WAL file size in bytes"


#-------------------------------------------------------------#
# pg_standby
# wal receiver stat
#-------------------------------------------------------------#
- pg_standby:
    query: "SELECT pid,
                   slot_name,
                   receive_start_lsn - '0/0'                 AS init_lsn,
                   receive_start_tli                         AS init_tli,
                   received_lsn - '0/0'                      AS last_lsn,
                   received_tli                              AS last_tli,
                   extract(EPOCH FROM last_msg_send_time)    AS send_ts,
                   extract(EPOCH FROM last_msg_receipt_time) AS receive_ts,
                   latest_end_lsn - '0/0'                    AS report_lsn,
                   extract(EPOCH FROM latest_end_time)       AS report_ts
            FROM pg_stat_wal_receiver;"
    options:
      min_version: 100000
      max_version: 130000
      cluster_level: true
      skip_primary: false
      skip_standby: false
      skip_error: false
      cache_seconds: 10
      timeout: 0
    metrics:
      - pid:
          usage: "LABEL"
          description: "pid of receiver process, unique pk"
      - slot_name:
          usage: "LABEL"
          description: "slot name of this standby server, if using"
      - init_lsn:
          usage: "COUNTER"
          description: "first time received lsn"
      - init_tli:
          usage: "GAUGE"
          description: "first time received timeline number"
      - last_lsn:
          usage: "COUNTER"
          description: "latest lsn that already flushed to standby disk"
      - last_tli:
          usage: "GAUGE"
          description: "latest timeline that already flushed to standby disk"
      - send_ts:
          usage: "GAUGE"
          description: "timestamp of sender sending last message"
      - receive_ts:
          usage: "GAUGE"
          description: "timestamp of receiving last message"
      - report_lsn:
          usage: "COUNTER"
          description: "lsn that already reporting to sender"
      - report_ts:
          usage: "GAUGE"
          description: "timestamp of last time reporting to sender"


#-------------------------------------------------------------#
# pg_checkpoint
# pg control checkpoint
#-------------------------------------------------------------#
- pg_checkpoint:
    query: "SELECT checkpoint_lsn - '0/0'       AS checkpoint_lsn,
               redo_lsn - '0/0'             AS redo_lsn,
               timeline_id                  AS timeline,
               split_part(next_xid, ':', 1) AS next_xid_epoch,
               split_part(next_xid, ':', 2) AS next_xid,
               next_oid,
               oldest_xid,
               oldest_active_xid,
               oldest_commit_ts_xid,
               newest_commit_ts_xid,
               extract(EPOCH FROM checkpoint_time)    AS checkpoint_time
        FROM pg_control_checkpoint();"
    options:
      min_version: 100000
      max_version: 130000
      cluster_level: true
      skip_primary: false
      skip_standby: false
      skip_error: false
      cache_seconds: 100
      timeout: 0
    metrics:
      - checkpoint_lsn:
          usage: "COUNTER"
          description: "lsn of checkpoint"
      - redo_lsn:
          usage: "COUNTER"
          description: "redo start LSN"
      - timeline:
          usage: "GAUGE"
          description: "Current WAL timeline"
      - next_xid_epoch:
          usage: "GAUGE"
          description: "next xid epoch since this checkpoint"
      - next_xid:
          usage: "GAUGE"
          description: "next xid since this checkpoint"
      - next_oid:
          usage: "GAUGE"
          description: "next oid since this checkpoint"
      - oldest_xid:
          usage: "GAUGE"
          description: "oldest existing xid of the checkpoint"
      - oldest_active_xid:
          usage: "GAUGE"
          description: "oldest active xid of the checkpoint"
      - oldest_commit_ts_xid:
          usage: "GAUGE"
          description: "oldest xid with commit ts by the checkpoint"
      - newest_commit_ts_xid:
          usage: "GAUGE"
          description: "newest xid with commit ts by the checkpoint"
      - checkpoint_time:
          usage: "GAUGE"
          description: "timestamp of this checkpoint"


#-------------------------------------------------------------#
# pg_recovery
#-------------------------------------------------------------#
- pg_recovery:
    query: "SELECT min_recovery_end_timeline    AS min_timeline,
                   min_recovery_end_lsn - '0/0' AS min_lsn,
                   backup_start_lsn - '0/0'     AS backup_start_lsn,
                   backup_end_lsn - '0/0'       AS backup_end_lsn
              FROM pg_control_recovery();"
    options:
      min_version: 100000
      max_version: 130000
      cluster_level: true
      skip_primary: false
      skip_standby: false
      skip_error: false
      cache_seconds: 100
      timeout: 0
    metrics:
      - min_timeline:
          usage: "COUNTER"
          description: "pg control recovery min timeline"
      - min_lsn:
          usage: "COUNTER"
          description: "pg control recovery min lsn"
      - backup_start_lsn:
          usage: "COUNTER"
          description: "pg control recovery backup start lsn"
      - backup_end_lsn:
          usage: "COUNTER"
          description: "pg control recovery backup end lsn"


#-------------------------------------------------------------#
# pg_lock
#-------------------------------------------------------------#
- pg_lock:
    query: "SELECT datname, mode, coalesce(count, 0) AS count
            FROM (SELECT d.oid AS database, d.datname, l.mode FROM pg_database d,
                       unnest(ARRAY ['AccessShareLock','RowShareLock','RowExclusiveLock','ShareUpdateExclusiveLock',
                           'ShareLock','ShareRowExclusiveLock','ExclusiveLock','AccessExclusiveLock']) l(mode)
                  WHERE d.datname NOT IN ('postgres','template0','template1')) base
                     LEFT JOIN (SELECT database, mode, count(*) AS count FROM pg_locks
                     WHERE database IS NOT NULL GROUP BY database, mode) cnt USING (database, mode);"
    options:
      min_version: 100000
      max_version: 130000
      cluster_level: true
      skip_primary: false
      skip_standby: false
      skip_error: true
      cache_seconds: 10
      timeout: 0
    metrics:
      - datname:
          usage: "LABEL"
          description: "Name of the database"
      - mode:
          usage: "LABEL"
          description: "Type of lock"
      - count:
          usage: "COUNTER"
          description: "Number of locks of corresponding mode"


#-------------------------------------------------------------#
# pg_xact
#-------------------------------------------------------------#
- pg_xact:
    query: "WITH snap(v) AS (SELECT txid_current_snapshot()),
                 xset(v) AS  (SELECT txid_snapshot_xip(v) FROM snap),
                 xnum(v) AS (SELECT count(*) from xset),
                 xmin(v) AS (SELECT txid_snapshot_xmin(v) FROM snap),
                 xmax(v) AS (SELECT txid_snapshot_xmin(v) FROM snap)
            SELECT xmin.v AS xmin, xmax.v AS xmax, xnum.v AS xnum FROM xmin, xmax, xnum;"
    options:
      min_version: 100000
      max_version: 130000
      cluster_level: true
      skip_primary: false
      skip_standby: false
      skip_error: true
      cache_seconds: 10
      timeout: 0
    metrics:
      - xmin:
          usage: "GAUGE"
          description: "earliest txid that is still active"
      - xmax:
          usage: "GAUGE"
          description: "first as-yet-unassigned txid. txid >= this are invisible."
      - xnum:
          usage: "GAUGE"
          description: "current active transaction count"


#-------------------------------------------------------------#
# pg_activity
#-------------------------------------------------------------#
- pg_activity:
    query: "SELECT datname,
                   state,
                   coalesce(count, 0)             AS count,
                   coalesce(max_duration, 0)      AS max_duration,
                   coalesce(max_tx_duration, 0)   AS max_tx_duration,
                   coalesce(max_conn_duration, 0) AS max_conn_duration
            FROM (SELECT d.oid AS database, d.datname, a.state
                  FROM pg_database d,
                       unnest(ARRAY ['active','idle','idle in transaction','idle in transaction (aborted)','fastpath function call','disabled']) a(state)
                  WHERE d.datname NOT IN ('postgres','template0','template1')) base
                     LEFT JOIN (
                SELECT datname, state,
                       count(*) AS count,
                       max(extract(epoch from now() - state_change)) AS max_duration,
                       max(extract(epoch from now() - xact_start))   AS max_tx_duration,
                       max(extract(epoch from now() - backend_start)) AS max_conn_duration
                FROM pg_stat_activity WHERE backend_type = 'client backend' AND pid <> pg_backend_pid()
                GROUP BY datname, state
            ) a USING (datname, state);"
    options:
      min_version: 100000
      max_version: 130000
      cluster_level: true
      skip_primary: false
      skip_standby: false
      skip_error: true
      cache_seconds: 10
      timeout: 0
    metrics:
      - datname:
          usage: "LABEL"
          description: "database name"
      - state:
          usage: "LABEL"
          description: "client backend connection state"
      - count:
          usage: "GAUGE"
          description: "connection count of given (datname,state)"
      - max_duration:
          usage: "GAUGE"
          description: "max duration since state change among (datname, state)"
      - max_tx_duration:
          usage: "GAUGE"
          description: "max transaction duration since state change among (datname, state)"
      - max_conn_duration:
          usage: "GAUGE"
          description: "max backend session duration since state change among (datname, state)"


#-------------------------------------------------------------#
# pg_wait
#-------------------------------------------------------------#
- pg_wait:
    query: "SELECT datname, wait_event_type AS event, count(*) AS count
            FROM pg_stat_activity
            WHERE datname NOT IN ('postgres', 'template0', 'template1')
              AND backend_type = 'client backend'
              AND pid <> pg_backend_pid()
            GROUP BY datname, wait_event_type;"
    options:
      min_version: 100000
      max_version: 130000
      cluster_level: true
      skip_primary: false
      skip_standby: false
      skip_error: true
      cache_seconds: 10
      timeout: 0
    metrics:
      - datname:
          usage: "LABEL"
          description: "database name"
      - event:
          usage: "LABEL"
          description: "wait event type: LWLock, Lock, BufferPin, Activity, Extension, Client, IPC, Timeout, IO"
      - count:
          usage: "GAUGE"
          description: "wait event type count"


#-------------------------------------------------------------#
# pg_query
#-------------------------------------------------------------#
- pg_query:
    query: "SELECT datname,
                   queryid AS query,
                   sum(calls)               AS calls,
                   sum(total_time)          AS total_time,
                   sum(min_time)            AS min_time,
                   sum(max_time)            AS max_time,
                   sum(mean_time)           AS mean_time,
                   sum(stddev_time)         AS stddev_time,
                   sum(rows)                AS rows,
                   sum(shared_blks_hit)     AS shared_blks_hit,
                   sum(shared_blks_read)    AS shared_blks_read,
                   sum(shared_blks_dirtied) AS shared_blks_dirtied,
                   sum(shared_blks_written) AS shared_blks_written,
                   sum(local_blks_hit)      AS local_blks_hit,
                   sum(local_blks_read)     AS local_blks_read,
                   sum(local_blks_dirtied)  AS local_blks_dirtied,
                   sum(local_blks_written)  AS local_blks_written,
                   sum(temp_blks_read)      AS temp_blks_read,
                   sum(temp_blks_written)   AS temp_blks_written,
                   sum(blk_read_time)       AS blk_read_time,
                   sum(blk_write_time)      AS blk_write_time
            FROM pg_stat_statements s, LATERAL (SELECT datname FROM pg_database db WHERE db.oid = s.dbid) d
            GROUP BY datname, queryid
            ORDER BY calls DESC, total_time DESC LIMIT 20;"
    options:
      min_version: 100000
      max_version: 130000
      cluster_level: true
      skip_primary: false
      skip_standby: false
      skip_error: true
      cache_seconds: 100
      timeout: 0
    metrics:
      - datname:
          usage: "LABEL"
          description: "database name"
      - query:
          usage: "LABEL"
          description: "query identifier, bigint"
      - calls:
          usage: "COUNTER"
          description: "times been executed"
      - total_time:
          usage: "COUNTER"
          description: "Total time spent in the statement, in µs"
      - min_time:
          usage: "GAUGE"
          description: "Minimum time spent in the statement, in µs"
      - max_time:
          usage: "GAUGE"
          description: "Maximum time spent in the statement, in µs"
      - mean_time:
          usage: "GAUGE"
          description: "Mean time spent in the statement, in µs"
      - stddev_time:
          usage: "GAUGE"
          description: "Population standard deviation of time spent in the statement, in µs"
      - rows:
          usage: "COUNTER"
          description: "rows retrieved or affected by the statement"
      - shared_blks_hit:
          usage: "COUNTER"
          description: "shared block cache hits by the statement"
      - shared_blks_read:
          usage: "COUNTER"
          description: "shared blocks read by the statement"
      - shared_blks_dirtied:
          usage: "COUNTER"
          description: "shared blocks dirtied by the statement"
      - shared_blks_written:
          usage: "COUNTER"
          description: "shared blocks written by the statement"
      - local_blks_hit:
          usage: "COUNTER"
          description: "local block cache hits by the statement"
      - local_blks_read:
          usage: "COUNTER"
          description: "local blocks read by the statement"
      - local_blks_dirtied:
          usage: "COUNTER"
          description: "local blocks dirtied by the statement"
      - local_blks_written:
          usage: "COUNTER"
          description: "local blocks written by the statement"
      - temp_blks_read:
          usage: "COUNTER"
          description: "temp blocks read by the statement"
      - temp_blks_written:
          usage: "COUNTER"
          description: "temp blocks written by the statement"
      - blk_read_time:
          usage: "COUNTER"
          description: "time spent reading blocks, in µs (if track_io_timing is enabled)"
      - blk_write_time:
          usage: "COUNTER"
          description: "time spent writing blocks, in µs (if track_io_timing is enabled)"


#-------------------------------------------------------------#
# pg_indexing
#-------------------------------------------------------------#
- pg_indexing:
    query: "SELECT datname, pid, relid, relname, phase,
                   coalesce((CASE WHEN blocks_total > 0 THEN 1.0 * blocks_done / blocks_total ELSE NULL END),
                            (CASE WHEN tuples_total > 0 THEN 1.0 * tuples_done / tuples_total ELSE NULL END),
                            (CASE WHEN partitions_total > 0 THEN 1.0 * partitions_done / partitions_total ELSE NULL END),
                            (CASE WHEN lockers_total > 0 THEN 1.0 * lockers_done / lockers_total ELSE NULL END)) AS progress
            FROM pg_stat_progress_create_index pspci,
                 LATERAL (SELECT relname FROM pg_class c WHERE c.oid = pspci.relid) n;"
    options:
      min_version: 120000
      max_version: 130000
      cluster_level: true
      skip_primary: false
      skip_standby: false
      skip_error: true
      cache_seconds: 10
      timeout: 0
    metrics:
      - datname:
          usage: "LABEL"
          description: "database name"
      - pid:
          usage: "LABEL"
          description: "process id of indexing table"
      - relid:
          usage: "DISCARD"
          description: "relation id of indexed table"
      - relname:
          usage: "LABEL"
          description: "relation name of indexed table"
      - phase:
          usage: "LABEL"
          description: "index building phase"
      - progress:
          usage: "GAUGE"
          description: "the actual progress"


#-------------------------------------------------------------#
# pg_vacuuming
#-------------------------------------------------------------#

#-------------------------------------------------------------#
# pg_clustering
#-------------------------------------------------------------#

#-------------------------------------------------------------#
# pg_database
#-------------------------------------------------------------#
- pg_database:
    query: "SELECT datname,
                   pg_database_size(oid)      AS size,
                   age(datfrozenxid)          AS age,
                   datistemplate              AS is_template,
                   datallowconn               AS allow_conn,
                   datconnlimit               AS conn_limit,
                   datfrozenxid::TEXT::BIGINT as frozen_xid
            FROM pg_database;"
    options:
      min_version: 100000
      max_version: 130000
      cluster_level: true
      skip_primary: false
      skip_standby: false
      skip_error: false
      cache_seconds: 100
      timeout: 0
    metrics:
      - datname:
          usage: "LABEL"
          description: "database name"
      - size:
          usage: "GAUGE"
          description: "database size in bytes"
      - age:
          usage: "GAUGE"
          description: "database age calculated by age(datfrozenxid)"
      - is_template:
          usage: "GAUGE"
          description: "1 for template db , 0 for normal db"
      - allow_conn:
          usage: "GAUGE"
          description: "1 allow connection, 0 does not allow"
      - conn_limit:
          usage: "GAUGE"
          description: "connection limit, -1 for no limit"
      - frozen_xid:
          usage: "GAUGE"
          description: "tuple with xmin below this will always be visable (until wrap around)"


#-------------------------------------------------------------#
# pg_db
# note this query will return different number of columns
# e.g: checksum_failures , checksum_last_failure is provided in 12
#-------------------------------------------------------------#
- pg_db:
    query: "SELECT d.*, c.*
            FROM pg_stat_database d,
                 LATERAL (SELECT confl_tablespace, confl_lock, confl_snapshot, confl_bufferpin, confl_deadlock
                          FROM pg_stat_database_conflicts pdc WHERE pdc.datname = d.datname) c
            WHERE d.datname NOT IN ('postgres','template0','template1');"
    options:
      min_version: 100000
      max_version: 130000
      cluster_level: true
      skip_primary: false
      skip_standby: false
      skip_error: false
      cache_seconds: 10
      timeout: 0
    metrics:
      - datid:
          usage: "DISCARD"
          description: "Name of the database"
      - datname:
          usage: "LABEL"
          description: "Name of the database"
      - numbackends:
          usage: "GAUGE"
          description: "backends currently connected to this database"
      - xact_commit:
          usage: "COUNTER"
          description: "transactions in this database that have been committed"
      - xact_rollback:
          usage: "COUNTER"
          description: "transactions in this database that have been rolled back"
      - blks_read:
          usage: "COUNTER"
          description: "blocks read from disk in this database"
      - blks_hit:
          usage: "COUNTER"
          description: "blocks found in pg buffer"
      - tup_returned:
          usage: "COUNTER"
          description: "rows returned by queries in this database"
      - tup_fetched:
          usage: "COUNTER"
          description: "rows fetched by queries in this database"
      - tup_inserted:
          usage: "COUNTER"
          description: "rows inserted by queries in this database"
      - tup_updated:
          usage: "COUNTER"
          description: "rows updated by queries in this database"
      - tup_deleted:
          usage: "COUNTER"
          description: "rows deleted by queries in this database"
      - conflicts:
          usage: "GAUGE"
          description: "Number of queries canceled due to conflicts with recovery in this database. (slave only)"
      - temp_files:
          usage: "GAUGE"
          description: "Number of temporary files created by queries in this database"
      - temp_bytes:
          usage: "GAUGE"
          description: "Temporary file byte count"
      - deadlocks:
          usage: "GAUGE"
          description: "Number of deadlocks detected in this database"
      - checksum_failures:
          usage: "GAUGE"
          description: "Number of data page checksum failures detected in this database"
      - checksum_last_failure:
          usage: "GAUGE"
          description: "Time at which the last data page checksum failure was detected "
      - blk_read_time:
          usage: "COUNTER"
          description: "Time spent reading data file blocks by backends in this database, in milliseconds"
      - blk_write_time:
          usage: "COUNTER"
          description: "Time spent writing data file blocks by backends in this database, in milliseconds"
      - stats_reset:
          usage: "COUNTER"
          description: "Time at which these statistics were last reset"
      - confl_tablespace:
          usage: "COUNTER"
          description: "Number of queries in this database that have been canceled due to dropped tablespaces"
      - confl_lock:
          usage: "COUNTER"
          description: "Number of queries in this database that have been canceled due to lock timeouts"
      - confl_snapshot:
          usage: "COUNTER"
          description: "Number of queries in this database that have been canceled due to old snapshots"
      - confl_bufferpin:
          usage: "COUNTER"
          description: "Number of queries in this database that have been canceled due to pinned buffers"
      - confl_deadlock:
          usage: "COUNTER"
          description: "Number of queries in this database that have been canceled due to deadlocks"




###############################################################
# Database Level Metrics
#   These metrics are unique for different database. So it will
#   be executed for each database even they lies in same cluster
#   note you'd better provide a datname label in your query in
#   order to get rid of name collision
###############################################################


#-------------------------------------------------------------#
# pg_class
# expected execution time: 200µs
#-------------------------------------------------------------#
- pg_class:
    query: "SELECT CURRENT_CATALOG                                              AS datname,
                   relnamespace::RegNamespace                                   AS nspname,
                   relname,
                   relkind,
                   relpages,
                   reltuples,
                   CASE WHEN relkind = 'i' THEN NULL ELSE age(relfrozenxid) END AS relage
            FROM pg_class
            WHERE relnamespace NOT IN
                  ('pg_catalog'::regnamespace::oid, 'information_schema'::regnamespace::oid, 'pg_toast'::regnamespace::oid)
              AND relkind IN ('r', 'i', 'm', 't');"
    options:
      min_version: 100000
      max_version: 130000
      cluster_level: false
      skip_primary: false
      skip_standby: false
      skip_error: true
      cache_seconds: 100
      timeout: 200000
    metrics:
      - datname:
          usage: "LABEL"
          description: "database name of this relation"
      - nspname:
          usage: "LABEL"
          description: "schema name of this relation"
      - relname:
          usage: "LABEL"
          description: "relation name of this relation"
      - relkind:
          usage: "LABEL"
          description: "relation type: r:table i:index S:sequence m:mview t:toast"
      - relpages:
          usage: "GAUGE"
          description: "exact page count of this relation"
      - reltuples:
          usage: "GAUGE"
          description: "estimate relation tuples"
      - relage:
          usage: "GAUGE"
          description: "age of non-index relation"


#-------------------------------------------------------------#
# pg_bloat_table
#-------------------------------------------------------------#
- pg_bloat_table:
    query: "SELECT CURRENT_CATALOG AS datname, schemaname AS nspname, tblname AS relname , bs * tblpages AS size,
            CASE WHEN tblpages - est_tblpages_ff > 0 THEN (tblpages - est_tblpages_ff)/tblpages::FLOAT ELSE 0 END AS ratio
            FROM (
                     SELECT ceil( reltuples / ( (bs-page_hdr)*fillfactor/(tpl_size*100) ) ) + ceil( toasttuples / 4 ) AS est_tblpages_ff,
                            tblpages, fillfactor, bs, tblid, schemaname, tblname, is_na
                     FROM (
                              SELECT
                                  ( 4 + tpl_hdr_size + tpl_data_size + (2 * ma)
                                      - CASE WHEN tpl_hdr_size % ma = 0 THEN ma ELSE tpl_hdr_size % ma END
                                      - CASE WHEN ceil(tpl_data_size)::INT % ma = 0 THEN ma ELSE ceil(tpl_data_size)::INT % ma END
                                  ) AS tpl_size, (heappages + toastpages) AS tblpages, heappages,
                                  toastpages, reltuples, toasttuples, bs, page_hdr, tblid, schemaname, tblname, fillfactor, is_na
                              FROM (
                                       SELECT
                                           tbl.oid AS tblid, ns.nspname AS schemaname, tbl.relname AS tblname, tbl.reltuples,
                                           tbl.relpages AS heappages, coalesce(toast.relpages, 0) AS toastpages,
                                           coalesce(toast.reltuples, 0) AS toasttuples,
                                           coalesce(substring(array_to_string(tbl.reloptions, ' ') FROM 'fillfactor=([0-9]+)')::smallint, 100) AS fillfactor,
                                           current_setting('block_size')::numeric AS bs,
                                           CASE WHEN version()~'mingw32' OR version()~'64-bit|x86_64|ppc64|ia64|amd64' THEN 8 ELSE 4 END AS ma,
                                           24 AS page_hdr,
                                           23 + CASE WHEN MAX(coalesce(s.null_frac,0)) > 0 THEN ( 7 + count(s.attname) ) / 8 ELSE 0::int END
                                               + CASE WHEN bool_or(att.attname = 'oid' and att.attnum < 0) THEN 4 ELSE 0 END AS tpl_hdr_size,
                                           sum( (1-coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 0) ) AS tpl_data_size,
                                           bool_or(att.atttypid = 'pg_catalog.name'::regtype)
                                               OR sum(CASE WHEN att.attnum > 0 THEN 1 ELSE 0 END) <> count(s.attname) AS is_na
                                       FROM pg_attribute AS att
                                                JOIN pg_class AS tbl ON att.attrelid = tbl.oid
                                                JOIN pg_namespace AS ns ON ns.oid = tbl.relnamespace
                                                LEFT JOIN pg_stats AS s ON s.schemaname=ns.nspname AND s.tablename = tbl.relname AND s.inherited=false AND s.attname=att.attname
                                                LEFT JOIN pg_class AS toast ON tbl.reltoastrelid = toast.oid
                                       WHERE NOT att.attisdropped AND tbl.relkind = 'r' AND nspname NOT IN ('pg_catalog','information_schema')
                                       GROUP BY 1,2,3,4,5,6,7,8,9,10
                                   ) AS s
                          ) AS s2
                 ) AS s3
            WHERE NOT is_na;"
    options:
      min_version: 100000
      max_version: 130000
      cluster_level: false
      skip_primary: false
      skip_standby: false
      skip_error: true
      cache_seconds: 100
      timeout: 1000000
    metrics:
      - datname:
          usage: "LABEL"
          description: "database name of this table"
      - nspname:
          usage: "LABEL"
          description: "schema name of this table"
      - relname:
          usage: "LABEL"
          description: "relation name of this table"
      - size:
          usage: "GAUGE"
          description: "total size in bytes of this table"
      - ratio:
          usage: "GAUGE"
          description: "estimated bloat ratio of this table, 0~1"



#-------------------------------------------------------------#
# pg_bloat_index
# bloat index ratio, not all index are included
#-------------------------------------------------------------#
- pg_bloat_index:
    query: "SELECT CURRENT_CATALOG AS datname, nspname, idxname AS relname, relpages::BIGINT * bs AS size,
                   COALESCE((relpages - ( reltuples * (6 + ma - (CASE WHEN index_tuple_hdr % ma = 0 THEN ma ELSE index_tuple_hdr % ma END)
                                        + nulldatawidth + ma - (CASE WHEN nulldatawidth % ma = 0 THEN ma ELSE nulldatawidth % ma END))
                               / (bs - pagehdr)::FLOAT  + 1 )), 0) / relpages::FLOAT AS ratio
            FROM (
                 SELECT nspname,
                        idxname,
                        reltuples,
                        relpages,
                        current_setting('block_size')::INTEGER                                                               AS bs,
                        (CASE WHEN version() ~ 'mingw32' OR version() ~ '64-bit|x86_64|ppc64|ia64|amd64' THEN 8 ELSE 4 END)  AS ma,
                        24                                                                                                   AS pagehdr,
                        (CASE WHEN max(COALESCE(pg_stats.null_frac, 0)) = 0 THEN 2 ELSE 6 END)                               AS index_tuple_hdr,
                        sum((1.0 - COALESCE(pg_stats.null_frac, 0.0)) *
                            COALESCE(pg_stats.avg_width, 1024))::INTEGER                                                     AS nulldatawidth
                 FROM pg_attribute
                          JOIN (
                     SELECT pg_namespace.nspname,
                            ic.relname                                                   AS idxname,
                            ic.reltuples,
                            ic.relpages,
                            pg_index.indrelid,
                            pg_index.indexrelid,
                            tc.relname                                                   AS tablename,
                            regexp_split_to_table(pg_index.indkey::TEXT, ' ') :: INTEGER AS attnum,
                            pg_index.indexrelid                                          AS index_oid
                     FROM pg_index
                              JOIN pg_class ic ON pg_index.indexrelid = ic.oid
                              JOIN pg_class tc ON pg_index.indrelid = tc.oid
                              JOIN pg_namespace ON pg_namespace.oid = ic.relnamespace
                              JOIN pg_am ON ic.relam = pg_am.oid
                     WHERE pg_am.amname = 'btree' AND ic.relpages > 0 AND nspname NOT IN ('pg_catalog', 'information_schema')
                 ) ind_atts ON pg_attribute.attrelid = ind_atts.indexrelid AND pg_attribute.attnum = ind_atts.attnum
                          JOIN pg_stats ON pg_stats.schemaname = ind_atts.nspname
                                               AND ((pg_stats.tablename = ind_atts.tablename AND pg_stats.attname = pg_get_indexdef(pg_attribute.attrelid, pg_attribute.attnum, TRUE))
                                                        OR (pg_stats.tablename = ind_atts.idxname AND pg_stats.attname = pg_attribute.attname))
                 WHERE pg_attribute.attnum > 0
                 GROUP BY 1, 2, 3, 4, 5, 6
             ) est;"
    options:
      min_version: 100000
      max_version: 130000
      cluster_level: false
      skip_primary: false
      skip_standby: false
      skip_error: true
      cache_seconds: 100
      timeout: 1000000
    metrics:
      - datname:
          usage: "LABEL"
          description: "database name of this index"
      - nspname:
          usage: "LABEL"
          description: "schema name of this index"
      - relname:
          usage: "LABEL"
          description: "relation name of this index relation"
      - size:
          usage: "GAUGE"
          description: "total size in bytes of this index"
      - ratio:
          usage: "GAUGE"
          description: "estimated bloat ratio of this index, 0~1"


#-------------------------------------------------------------#
# pg_table
# note that database with tremendous of tables may suffer from
# this query. Use sampling filter or just disable it in that case
#-------------------------------------------------------------#
- pg_table:
    query: "SELECT CURRENT_CATALOG                     AS datname,
                   schemaname                          AS nspname,
                   relname,
                   seq_scan,
                   seq_tup_read,
                   idx_scan,
                   idx_tup_fetch,
                   n_tup_ins,
                   n_tup_upd,
                   n_tup_del,
                   (n_tup_ins + n_tup_upd + n_tup_del) AS n_tup_mod,
                   n_tup_hot_upd,
                   n_live_tup,
                   n_dead_tup,
                   n_mod_since_analyze,
                   last_vacuum,
                   last_autovacuum,
                   last_analyze,
                   last_autoanalyze,
                   vacuum_count,
                   autovacuum_count,
                   analyze_count,
                   autoanalyze_count
            FROM pg_stat_user_tables;"
    options:
      min_version: 100000
      max_version: 130000
      cluster_level: false
      skip_primary: false
      skip_standby: false
      skip_error: true
      cache_seconds: 10
      timeout: 2000000
    metrics:
      - datname:
          usage: "LABEL"
          description: "database name of this relation"
      - nspname:
          usage: "LABEL"
          description: "schema name of this relation"
      - relname:
          usage: "LABEL"
          description: "relation name of this relation"
      - seq_scan:
          usage: "COUNTER"
          description: "sequential scans initiated on this table"
      - seq_tup_read:
          usage: "COUNTER"
          description: "live rows fetched by sequential scans"
      - idx_scan:
          usage: "COUNTER"
          description: "index scans initiated on this table"
      - idx_tup_fetch:
          usage: "COUNTER"
          description: "rows fetched by index scans"
      - n_tup_ins:
          usage: "COUNTER"
          description: "rows inserted"
      - n_tup_upd:
          usage: "COUNTER"
          description: "rows updated"
      - n_tup_del:
          usage: "COUNTER"
          description: "rows deleted"
      - n_tup_mod:
          usage: "COUNTER"
          description: "rows modified (insert + update + delete)"
      - n_tup_hot_upd:
          usage: "COUNTER"
          description: "rows updated in HOT mode"
      - n_live_tup:
          usage: "GAUGE"
          description: "estimated live rows"
      - n_dead_tup:
          usage: "GAUGE"
          description: "estimated dead rows"
      - n_mod_since_analyze:
          usage: "GAUGE"
          description: "rows changed since last analyze"
      - last_vacuum:
          usage: "GAUGE"
          description: "when table was manually vacuumed last time (FULL not count)"
      - last_autovacuum:
          usage: "GAUGE"
          description: "when table was automatically vacuumed last time"
      - last_analyze:
          usage: "GAUGE"
          description: "when table was manually analyzed last time"
      - last_autoanalyze:
          usage: "GAUGE"
          description: "when table was automatically analyzed last time"
      - vacuum_count:
          usage: "COUNTER"
          description: "manual vacuum count (FULL not count)"
      - autovacuum_count:
          usage: "COUNTER"
          description: "automatic vacuum count"
      - analyze_count:
          usage: "COUNTER"
          description: "manual analyze count"
      - autoanalyze_count:
          usage: "COUNTER"
          description: "automatic analyze count"


#-------------------------------------------------------------#
# pg_index
# note that database with tremendous of tables may suffer from
# this query. Use sampling filter or just disable it in that case
#-------------------------------------------------------------#
- pg_index:
    query: "SELECT CURRENT_CATALOG AS datname,
                   schemaname      AS nspname,
                   indexrelname    AS relname,
                   idx_scan,
                   idx_tup_read,
                   idx_tup_fetch,
                   idx_blks_read,
                   idx_blks_hit
            FROM pg_stat_user_indexes psui,
                 LATERAL (SELECT idx_blks_read, idx_blks_hit FROM pg_statio_user_indexes psio
                 WHERE psio.indexrelid = psui.indexrelid) p2;"
    options:
      min_version: 100000
      max_version: 130000
      cluster_level: false
      skip_primary: false
      skip_standby: false
      skip_error: true
      cache_seconds: 10
      timeout: 2000000
    metrics:
      - datname:
          usage: "LABEL"
          description: "database name of this relation"
      - nspname:
          usage: "LABEL"
          description: "schema name of this relation"
      - relname:
          usage: "LABEL"
          description: "relation name of this relation"
      - idx_scan:
          usage: "COUNTER"
          description: "index scans initiated on this index"
      - idx_tup_read:
          usage: "COUNTER"
          description: "index entries returned by scans on this index"
      - idx_tup_fetch:
          usage: "COUNTER"
          description: "live table rows fetched by simple index scans using this index"
      - idx_blks_read:
          usage: "COUNTER"
          description: "blocks been read from disk of this index"
      - idx_blks_hit:
          usage: "COUNTER"
          description: "blocks hit from cache of this index"


#-------------------------------------------------------------#
# pg_func
# note that database with tremendous of tables may suffer from
# this query. Use sampling filter or just disable it in that case
#-------------------------------------------------------------#
- pg_func:
    query: "SELECT CURRENT_CATALOG AS datname,
                   schemaname      AS nspname,
                   funcname,
                   calls,
                   total_time,
                   self_time
            FROM pg_stat_user_functions;"
    options:
      min_version: 100000
      max_version: 130000
      cluster_level: false
      skip_primary: false
      skip_standby: false
      skip_error: true
      cache_seconds: 10
      timeout: 1000000
    metrics:
      - datname:
          usage: "LABEL"
          description: "database name of this relation"
      - nspname:
          usage: "LABEL"
          description: "schema name of this relation"
      - funcname:
          usage: "LABEL"
          description: "relation name of this relation"
      - calls:
          usage: "COUNTER"
          description: "how many times this function has been called"
      - total_time:
          usage: "COUNTER"
          description: "how much time spent in this function and it's child function, in ms"
      - self_time:
          usage: "COUNTER"
          description: "how much time spent in this function itself (other func not included), in ms"

